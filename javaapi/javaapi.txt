
java 1.8数据结构：   
#(继承用==>表示 、 实现用-->表示)

1. 接口 Collection

集合接口的根接口，一个集合表示一组元素。
有些实现允许重复有些不允许，有些有序有些无序

jdk没有直接实现该接口，提供了一些它的子接口的实现

集合的实现类 规定要有2个构造方法，一个无参构的创建一个空集合，
一个带有一个 Collection 类型参数的构造方法，使用参数Collection内的元素来填充本Collection，可以当做是copy元素到另一个Collection实现



不支持的操作会抛出 UnsupportedOperationException 异常

有些实现会元素有限制，例如 非null 和 元素类型的限制，操作不当会抛出 NullPointerException / ClassCastException
查询不合格的元素可能会抛出异常，也可能会返回false
插入不合格的元素可能会成功也可能会抛出异常，这取决于实现时的决定


每个实现决定自己的同步策略，没有保证同步的集合实现可能会在多线程使用时产生不确定结果，
例如直接调用方法时，或使用集合的某个方法，或者使用迭代器

Collectin框架中的许多接口方法都是用到了equals。
例如：contains方法（o==null? e==null: o.equals(e)）， 如果入参是非null数据，
会调用到Object的equals方法



2. 接口 Set 继承自 Collection
	Collection ==> Set  

不予许有重复，即不能有 a.equals(b) ，包括null. 不能保存Set本身

一些Set的实现 会限制不允许有null 有的限制类型
同Collection 相同 ：操作不合法元素时 可能会抛异常 或者返回 false,取决于具体实现类


3. 接口 List 继承 Collection
	Collection ==> List

提供有序的集合或序列， List 可以精确控制每个元素的插入位置，以及通过索引访问元素，
提供了4个通过的索引操控元素的方法 ： add \ set \ remove \ get

与Set 不同的是 List 允许多个重复元素 和null如果可以的话， 为List添加 不可重复元素的限制是很少见的

为了遍历List声明了一些Collection 已有的方法： iterator \ add 、 remove \ equals \ hashCode

提供了一个特殊 迭代器 ListIterator ，除了iterator 功能外还包含了添加、替换元素 、 向前遍历元素 的功能 ，
并提供了一个从特定位置开始使用ListIterator 迭代的方法

提供了2个查询指定元素的方法： indexOf(Objecy) \ lastIndexOf(Object) ，出于性能考虑使用时需谨慎，大部分实现类都使用的代价高昂的线性查询

分别提供2个高效的添加和删除元素的方法 add(int , E) \ add(E) \ remove(int) \ remove(Object)

List 允许添加自己作为元素，但强烈建议这样使用时不定义equals 和 hashCode 方法


4. 抽象类 AbstractCollection 实现 Collection
	Collection  -->  AbstractCollection
	
	
提供了Collection 的基本实现，以尽量减少此接口的实现工作量 . 
实现了 isEmpty 、 contains \ containsAll \ add \ addAll \ clear \ remove \ removeAll \ retainAll \ toArray \ toString
未实现 iterator  \ size 

如果只想用一个不可修改的集合，则只需要继承这个类，并提供 iterator 、 size 方法的实现即可

如果想实现一个可修改的集合，需要重写 add ，实现iterator 接口的 iterator 、 remove 方法 


5. 抽象类 AbstractSet 继承abstractCollection  实现 Set 
    Collection --> AbstractCollection	==>  AbstractSet
	Collection ==> Set 					-->  AbstractSet
	

提供了 Set 的基本骨架实现，以减少实现Set的工作量

只增加了 equals 、 hashCode ，增强了removeAll 方法，其他的与abstractCollection 没区别，
注意实现类需要按照Set的要求不能有重复对象



6. 抽象类 AbstractList 继承自 AbstractCollection ， 实现 List
	Collection --> AbstractCollection  ==>  AbstractList
	Collection ==> List		           -->  AbstractList
	
提供了 List基本骨架实现，以减少实现List的工作量，
像数组那样支持随机位置访问，如果想按顺序访问元素 应该优先使用 AbstractSequentialList

如果想实现只读的List ， 只需要继承List，并实现 get(int) \ size() 方法即可

如果想实现可修改的List ， 需要重写 set(int, E) 方法，
如果List是可变长度的还需要重写add(int, E) \ reomve(int) 方法  

与其他 Collection 的实现类不同，AbstractList不需要使用者实现iterator 的实现， 
iterator \ ListIterator 已经在AbstractList中实现 

定义了4个 随机位置访问方法（random method）： get(int) \ set(int, Object) \ add(int, Object) \ remove(int) ， 实现类重写或实现

非抽象方法的实现都有详细描述，除非使用者有更高效的实现方法一般不必重写它们。


7. 类 ArrayList ，继承自 AbstractList , 实现 List \ RandomAccess, Cloneable, java.io.Serializable

	Collection --> AbstractCollection  ==>  AbstractList  ==>  ArrayList
	Collection ==> List		           -->  AbstractList   
	Collection ==> List              ----------------------->  ArrayList

使用可变长度数组来实现List, 可以添加null元素，还添加了一些处理数组长度的方法。除了不是同步的大致与Vector相同

ArrayList 内部保存元素的数组都有一个容量，容量至少等于List的长度。不断添加元素 数组长度会自动 翻倍扩容
在添加大量元素前最好手动增加数组长度

不是线程安全的，多个线程进行结构性修改操作时应该在外层有同步控制，一般通过一个封装类封装 List,
如果没有可以使用Collections.SynchronizedCollection 类， 这个类方法都加上了synchronized

iterator 迭代器是快速失败的，当创建了iterator后如果不是通过iterator自己的remove add 方法修改list的结构，则会抛出
ConcurrentModificationException 的异常，不能根据这个特点保证并发同步操作的正确性，只能用来发现bug

8. 类 Vector ，继承自AbstractList , 实现 List<E>, RandomAccess, Cloneable, java.io.Serializable

	Collection --> AbstractCollection  ==>  AbstractList  ==>  Vector
	Collection ==> List		           -->  AbstractList   
	Collection ==> List              ----------------------->  Vector

使用可变长度数组来实现Vector ，可以手动扩充数组长度，删除元素时也会自动缩减长度。 Vector 是线程安全的

内部有2个管理数组的变量 容量capacity 、 扩容大小capacityIncrement ，可以构造时指定
数组最大长度是Integer.MAX_VALUE - 8 ，当数组不够时增加capacityIncrement的长度，如果capacityIncrement<0， 则翻倍增长

iterator 是快速失败的



9. 接口 Queue , 继承 Collection
	
	Collection ==> Queue

一种用来处理保存进来的数据的集合实现。	

除了Collection的基本操作外，还额外提供了 插入、提取、检查操作，并且每个操作有2种实现，一种操作失败时抛异常、一种返回特殊值（null或false），
返回特殊值的插入操作 特别适合有限长度集合的实现中使用。

队列通常但不必须按照先进先出（FIFO）的方式排列元素，
例如：优先级队列，按照提供的比对方法进行排序 ；按照自然顺序；按照后进先出（LIFO）（堆）

不论使用何种排序方法，remove \ poll 方法都会移除队列头部元素

FIFO队列新插入的元素放在队列底部，其他排序实现的队列会有不同放置位置，每个队列实现都要指定自己的排序方法

add \ offer 方法尝试插入一个元素，如果失败返回false. 与add不同的是 add会返回 unchecked exception
offer 被设计为返回失败比抛异常正常的情况，比如在固定长度队列中使用。

remove \ poll  都会删除queue 的head元素并返回，删除并返回的具体元素根据不同queue实现排序策略决定，
当队列为空时 poll会返回null, remove会抛异常

element \ peek  方法返回 queue的head元素，但不删除 

Queue 没有定义并发操作时使用的阻塞方法（例如 ： 获取元素时等待新元素插入，或者插入元素时等待有空间被释放），阻塞的Queue实现：BlockingQueue

Queue 一般不允许插入null，即使实现类允许插入null，也不应该插入，因为poll 方法会返回null，表示队列中没有元素。

Queue 一般不定义基于元素的 equals 和 hashCode 方法，而是使用基于身份的 从Object 继承的equals \ hashCode方法，
因为 相同元素 在以不同排序方式实现的Queue队列中 不总是定义明确的



10. 接口 Deque<E> ， 继承Queue<E>
	Collection ==> Queue ==> Deque

线性集合，支持从前端或后端 进行添加和删除 ,dobule end queue
Deque 的实现大多是没有容量长度限制的，也有有限制的

与Queue 一样 ，Deque 提供两套 方法 插入、提取、检查 元素，两套方法中都有从头和尾端操作元素的方法。 一套错误时抛异常一套返回null or false

FIFO 策略 （队列）实现方式 使用如下方法 ,并且Queue和Deque中的方法功能相同
java.util.Queue#add  \ addLast
java.util.Queue#offer \  offerLast
java.util.Queue#remove \ removeFirst
java.util.Queue#poll \ pollFirst
java.util.Queue#element \ getFirst
java.util.Queue#peek \ peek   ：永远从头返回当前元素

LIFO 策略 （栈）实现方式 使用如下方法 ， 并且Stack和Deque中的方法功能相同
push \ addFirst
pop \ removeFirst
peek \ peekFirst

提供2个 移除指定元素的方法，
removeFirstOccurrence : 从头开始移除遇到的第一个 equals的元素
removeLastOccurrence :  从尾开始移除遇到的第一个 equals的元素

其他特性与Queue 一样，不提倡添加null元素

11. 抽象类 AbstractQueue ，继承AbstractCollection , 实现Queue
	Collection ==> Queue              --> AbstractQueue
	Collection --> AbstractCollection ==> AbstractQueue
	
提供Queue基本骨架方法实现，当基础实现不允许插入null, 这个实现是适当的。

因为实现的 add \ remove \ element 方法，分别调用 offer \ poll \ peek ，并且遇到null时会抛异常

实现这个类 至少要 实现 offer \ poll \ peek ,并且不能插入null


12. 抽象类 AbstractSequentialList<E> ， 继承AbstractList<E>
	Collection --> AbstractCollection  ==>  AbstractList  ===>  AbstractSequentialList
	Collection ==> List		           -->  AbstractList  ===>  
	
提供了基于顺序访问元素的 List基本骨架实现，以减少实现接口的工作量。 没有index元素位置，如果想随机访问元素，应该使用AbstractList

与AbstractList 的随机访问方式不同，AbstractSequentialList的 get(int) , set(int, E) , add(int, E) , remove(int) 
方法基于ListIterator的功能来实现（靠next 或prev 遍历来定位元素，因此效率比较低）

实现AbstractSequentialList ，需要实现listIterator \ size方法
如果实现的是只读的，只需要实现ListIterator 的 hasNext \ next \ hasPrevious \ previous \ index 方法
实现的是可修改的， 需要实现 ListIterator 的 set \ remove \ add 方法


13. 类LinkedList<E> ， 继承AbstractSequentialList<E> ,  实现 List<E>, Deque<E>
    Collection --> AbstractCollection  ==>  AbstractList  ===>  
    Collection ==> List		           -->  AbstractList  ===>   AbstractSequentialList  ==> 
	Collection ==> List                ---------------------------------------------------->  
    Collection ==> Queue ==> Deque     ---------------------------------------------------->  LinkedList

	
实现了所有list 的操作，可以保存null元素，有双向列表功能。

通过索引访问元素，也需要对列表进行遍历，因此效率不高，（根据索引位置选择从前往后或从后往前遍历直到找到元素）

不是同步的，如果有多线程并发访问并修改列表结构（添加、删除元素），则需要进行封装，或者使用Collections.synchronizedList 方法创建SynchronizedList类（此类中方法加上了synchronized）

和ArrayList \ Vector（List其他实现）迭代器是快速失败的，不能根据这个特点保证并发同步操作的正确性，只能用来发现bug


14. 接口BlockingQueue<E> 继承 Queue<E>
    Collection ==> Queue  -->  BlockingQueue
	
在Queue基础上增加了等待功能（从一个空队列中获取元素时等待直到有元素进入队列，向一个满队列插入输入时等待队列释放空间满足可用时在插入 ）

BlockingQueue 的方法，在面对不能立刻满足操作条件时有4种处理方式: 抛异常 、 返回特殊值 、 等待直到满足条件 、 等待一段时间仍不满足放弃
分别如下：
add(e) / offer(e) / put(e) / offer(Object, long, TimeUnit) offer(e, time, unit)
remove() / poll() / take() / poll(long, TimeUnit) poll(time, unit)
element() / peek() / not applicable / not applicable

不接受null元素，使用null会抛NullPointerException

存储空间可以是定长的，在给定的时间间隔会执行 remainingCapacity 获得可用空间大小，没有强制要求空间大小，最大为Integer.MAX_VALUE

主要是作为生产-消费者队列来设计，遍历BlockingQueue 效率不高

是线程安全的，但是批量操作 addAll \ containsAll \ retainAll \ removeAll 不是原子的，可能部分成功

作为 生产-消费 队列来使用时 往往需要知道生产者是否向队列中放入数据完毕，BlockingQueue并没有提供这样的方法，
可以使用特殊值（毒药对象）当消费者或得到特殊值代表生产者结束向队列添加元素
























