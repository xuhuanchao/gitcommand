### 算法：

1.  定义：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作

2.  特性：输入、输出、有穷性、确定性、可行性
    1）输入输出有0或多个输入、至少一个输出；
    2）有穷性：算法在有限步骤完成，不会出现无限循环，每一步在可接受的时间内完成
    3）确定性：算法每一步都有确定的含义，没有二义性
    4）可行性：算法每一步都是可行的，通过执行有限次数完成

3.  算法设计要求
    1）正确性：有输入、输出和加工处理无歧义性，能正确反映问题的需求、得到正确答案。
    四个层次：
        a 没有语法错误
        b 对于合法输入能产生满足要求的输出结果
        c 对于非法输入能得出满足规格的说明结果
        d 对所有输入都有满足需要的输出
    2）可读性：方便阅读、理解和交流
    3）健壮性：输入不合法数据能做出相关处理，不会产生异常和莫名其妙的结果
    4）事件效率高和存储量低

4.  算法效率度量方法
    1）事后统计方法
    通过设计好的程序，利用计算机计时，比较时间长短
    缺陷：必须编写好程序，时间受计算机硬件和软件环境因素影响，算法测试数据设计困难数据规模影响算法时间。

    2）事前分析估算方法
    算法耗时主要取决的因素：
    a 算法采用的策略、方法
    b 编译产生的代码质量
    c 问题的输入规模
    d 机器执行指令的速度


    抛开机器和软件，效率主要由算法策略和输入规模决定
    例子： 1+2+3+...100

    算法1
    int i, sum=0, n=100         /* 1次 */
    for(i =1; i<n; i++){          n+1
        sun = sun+1;              n
    }
    printf("%d", sum);             1

    算法2
    int sum=0, n=100;           1
    sum = (1+n) * n/2;          1
    printf("%d", sum);          1

    算法3
    int i,j,x = 0, sum=0, n=100;        1
    for(i=1; i<=n; i++){
        for(j=1; j<=n; j++){
            x++;                        n*n
            sum = sum + x;
        }
    }
    printf("%d", sum);                  1

    忽略定义和打印只关注中间部分， 3个算法是n 与 1 与 n平方的差距
    f(n) = n, f(n) = 1, f(n) = n平方
    事件复杂度分别为：O(n), O(1), O(n^2)

    判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数

5.  时间复杂度
    T(n) = O(f(n))
    f(n)是问题规模n的某个函数，O()体现算法时间复杂度，随着n的增长T(n)增长最慢的算法为最优算法

    推导大O阶：
    1）用常数1取代运行时间中的所有加法常数
    2）在修改后的运行次数函数中，只保留最高阶项
    3）如果最高阶项存在且不是1，则去除与这个项相乘的常数


    1）常数阶
    int sum=0, n=100;       /* 执行1次 */
    sum = (1+n)*n/2;        /* 执行1次 */
    sum = (1+n)*n/2;        /* 执行1次 */
    sum = (1+n)*n/2;        /* 执行1次 */
    ......
    O(1\2\3\.....) 无论多少都记作O(1)

    2）线性阶
    int i;
    for(i =0; i<n; i++){
        时间复杂度为O(1)的操作步骤
    }
    时间复杂度为O(n)

    3）对数阶
    int count = 1;
    while(count < n){
        count = count * 2;
        时间复杂度为O(1)的步骤
    }
    有多少个2相乘大于n则退出循环，2^x = n , x=log2n
    O(logn)

    4）平方阶
    int i,j;
    for(i=0; i<n; i++){
        for(j=0; j<n; j++){
            O(1)...
        }
    }
    O(n^2)， 若2层循环次数不同则 O(m*n)


### 线性表

零个或多个数据元素的有限序列，每个元素类型一致，只有一个前驱和后继元素，元素之间关系是一对一关系

1.  线性表的顺序存储结构

    1）线性表 顺序存储结构
    指用一段地址连续的存储单元依次存储线性表的数据元素

    2）顺序存储方式
    一位数组实现顺序存储结构，有3个属性：存储空间的起始位置、最大存储容量、当前的长度。

    3）操作效率
    随机存取
    第i个数据元素的存储位置： Loc（ai）= Loc(a1)+(i-1)*c
    c是每个元素占用的存储空间大小
    Loc(a1)是第a1个元素所在存储位置

    由公式可知每个位置的存储位置计算性能都是O(1)，因此这种存储结构也称为随机存取结构.

    插入删除时时间复杂度都是O(n)，因为要移动元素

    4）优缺点
    优点：不需要存储元素之间关系的数据，可以快存取元素
    缺点：插入和删除需要移动大量元素，不容易确定存储空间容量，容易浪费容量


2.  线性表的链式存储结构 单链表
    每个元素除了存储数据外还存储一个指示后续元素位置的信息，称为数据域和指针域，n个节点链节成一个链表，即为线性表（a1..an）的链式存储结构.因为只有一个指针域所以叫单链表。

    1）存储结构
    链表中第一个节点位置称为头指针：数据域存数据信息，指针域存下一个元素位置.
    第一个节点前附设一个节点称为头节点：数据域为空或存链表长度等信息，指针域存头指针地址.

    2）操作效率
    读取和插入删除的效率O(n)，但是如果在一个位置插入多个值那么第一次以后每次的效率是O(1)，比顺序存储结构快.

    3）优缺点
    优点：不需要先分配存储空间，元素个数不受限，在查出位置后在该位置插入和删除的效率为O(1)。读取多的可以用顺序结构，修改多的用链式结构.已知固定长度的数据可以用顺序结构

3.  线性表的循环存储结构 循环链表
    单向循环链表：将单链表中终端节点的指针由空改为指向头结点。
    双向循环链表：单链表的每个结点中再设置一个指向其前驱结点的指针域。


### 栈

4.  栈
    栈（stack）是限定仅在表尾进行插入和删除操作的线性表。

    1）栈的顺序存储结构
    使用数组存储元素，0端做为栈底，定义一个变量（top）存储栈顶元素位置

    2）两栈共享存储空间
    一个栈的栈底为数组0端，另一个栈的栈底为数组长度（n）-1端。
    top1 = -1 、 top2 = n 代表2个栈是否为空栈
    top1 + 1 = top2 时为栈满

    3）栈的链式存储结构
    使用单链表，去掉头结点，定义一个变量（top）存储栈顶元素位置，栈顶位置定在头指针位置。头指针指向空时代表栈为空栈。

    4）时间效率
    顺序存储与链式存储均为O(1)

    5）栈的作用
    简化程序设计，划分不同关注层次，缩小思考范围，只关注于问题核心。

    6）栈的应用-递归

    斐波那契数列
    int Fbi(int i){
        if(i < 2){
            return i == 0 ? 0 : 1;
        }
        return Fbi(i-1) + Fbi(i-2);
    }
    int main(){
        int i;
        for(int i=0; i<40; i++){
            printf("%d ", Fbi(i));
        }
        return 0;
    }

    四则运算表达式（中缀），转为后缀（逆波兰）表示法
    9 + (3 - 1) * 3 + 10 ／ 2  =>  9 3 1 - 3 * + 10 2 / +

    后缀表达式的计算方法，使用栈计算：
    从左到右遍历每个数字和符号，遇到数字就进栈，遇到符号就将栈顶2个数字出栈进行运算，运算结果进栈，一直到获得最终结果。


    9 3 1 <-top ，   遇到 - 将3 1 出栈运算得到2 ，2再入栈
    9 2 <-top
    9 2 3 <-top ，   遇到 * 将 2 3 出栈运算得到6，6入栈
    9 6 <-top ，     遇到 + 将 9 6 出栈运算得到15 入栈
    15 <-top
    15 10 2 <-top ,  遇到 ／ 将10 2 出栈运算得到5 ， 5入栈
    15 5 <-top ,     遇到 + 将15 5 出栈运算得到20，得到最终结果


    中缀表达式转后缀表达式方法：
    从左到右遍历表达式中的每个数字和符号，若是数字就输出称为表达式的一部分，若是符号就判断栈顶的符号与当前符号优先级，如果栈顶符号优先级大于当前符号，则栈中符号依次出栈输出到表达式，当前符号进栈，若当前符号是括号如果栈中有匹配的括号，则这2个符号间的符号依次出栈并输出到表达式，当前括号和栈中匹配的括号出栈并移除不输出到表达式，直到便利完成栈中的所有符号依次出栈。

    以9 + (3 - 1) * 3 + 10 ／ 2  =>  9 3 1 - 3 * + 10 2 / + 为例：

    输出：9  栈： + (  <-top
    输出：9 3  栈： + ( - <-top
    输出：9 3 1  栈： + ( - <-top
    输出：9 3 1 - 栈： + <-top  当前符号) 匹配上了( 所以() 之间的-出栈，()被移除
    输出：9 3 1 - 栈： + * <-top
    输出：9 3 1 - 3 栈： + * <-top
    输出：9 3 1 - 3 * + 栈： + <-top 当前符号+ 比战中的 * 号优先级低，所以* + 依次出栈后 当前符号+进栈。
    输出：9 3 1 - 3 * + 10 栈： + <-top
    输出：9 3 1 - 3 * + 10 栈： + / <-top
    输出：9 3 1 - 3 * + 10 2 栈： + / <-top
    输出最终结果：9 3 1 - 3 * + 10 2 / + 栈：空，遍历完毕栈中所有符号依次出栈


5.  队列
    只允许在一端进行插入操作，在另一端进行删除操作的线性表
    有先进先出性FIFO

    队列存储结构有顺序存储和链式存储

    顺序存储
    同线性表的顺序存储结构，以0端做为队头，另一端为队尾，从队尾添加元素队头删除元素，删除元素需要将后面的元素往前移动，造成时间效率为O(n),如果不移动又容易空间浪费不能重复利用已删除的位置。
    定义front指针指向队头位置，rear指针指向队尾位置

    循环队列
    把头尾相接的顺序存储结构称为循环队列。
    如果空间允许，当rear已指向在数组最后位置可以将新元素添加到0的位置，rear指向0。

    4 <-rear null null 1 2 3 <-front

    预留一个空位置当队列满的时候就是只有一个空位置的时候。设队列长度用n表示，则判断队列已满公示 (rear+1)%n = front 时代表队列满。

    队列长度计算公式： (rear-front + n)%n


    队列的链式存储结构
    就是用线性表的单链表结构存储，只是限制了只能从头出而已。
    时间效率为n(1)。

    如果可以确定队列长度建议使用循环队列，如果无法确定则使用链队列。


### 串

6.  串String
    是由零个或多个字符组成的有限序列，有名叫字符串

    1）比较大小
    从第一个字符比较ascii码的大小，大的所在串就大

    2）逻辑结构
    串的逻辑结构与线性表很相似，线性表关注单个元素的操作，串更多的是查找子串、定位子串、替换子串等

    3）存储结构
    使用固定长度的空间顺序存储、链式存储结构。链式存储在连接串操作比较便利，总体不如顺序存储灵活和性能高。

    4）朴素模式匹配子串
    主串S，子串T。
    从S的第一位开始与T的第一位比较，如果相同，S与T再比较下一位直到子串全部匹配相同则说明子串匹配成功，如果遇到不同则从S的第二位开始与T的第一位比较，以此类推

    n为主串S的长度，m为子串T的长度，平均时间复杂度为(n+m)/2，最快为O(1)，最慢为O((n-m+1)*m)


    朴素模式匹配实现代码：
    /*
    *   S：主串， T：子串， pos：主串匹配的起始位置
    *   S[0],T[0]：存储S、T串的长度
    */
    int Index(String S, String T, int pos){
        int i=pos;
        int j=1;
        while(i <= S[0]){
            if(S[i] == T[j]){
                ++i;
                ++j;
            }else{
                i = i-j+2;
                j=1;
            }
        }
        if(j > T[0]){
            return i-T[0];
        }else{
            return 0;
        }
    }


    例子:
    S:123442 , T:123414 , i:S的坐标 j:T的坐标
    123442   i=5 j=5
    123414

    123442   i=2 j=1
     123414

    123442   i=3 j=1
      123414

    123442   i=4 j=1
       123414

    123442   i=5 j=1
        123414

    123442   i=6 j=1
         123414

    123442   i=7 j=1 超出S长度，循环判断终止
          123414


    5）KMP模式匹配算法

    ## KMP是为了省去不必要的匹配操作。

    例子1:
    S:abcdefgab T:abcdex 串进行比较，i表示主串S当前比较字符的位置，j表示子串T当前比较字符的位置。
    当比较到
    abcdefgab
    abcdefx
    第7位 S：g 与T：x 不相等时，可以略过朴素模式中从S的第2-6位开始的比较，直接从第7位比较：
    abcdefgab
          abcdefx
    因为S串的2-6位与T串的2-6位相同，T串的第一位与后面2-6位的字符不同，可以推断出子串T的第1位不可能与S串的第2-6位相同，所以可以略过这些比较操作。

    例子2:
    S：abcabcabc T:abcabx
    abcabcabc
    abcabx

    第6位 c与x不等
    根据刚才的规律看，可以直接比较第4位
    abcabcabc
       abcabx

    但发现T的1、2位与4、5位的ab相等之前比较时也验证了S的4、5位与T的4、5位相等，则可以省略掉本次的4、5位的比较直接比较S的第6位与T的第3位。

    朴素模式匹配算法就是不断回溯主串i和子串j的值来完成比较的，KMP模式匹配就是为了减少没必要的回溯发生。


    ## KMP模式方法：

    KMP模式匹配可以在判断出现不等时下次循环判断保持i值不变，减少主串的回溯，而子串位置j的变化取决于子串的前后缀的相似度。
    获取子串回溯时j值变化的规律是KMP的关键，只与子串T本身有关。

    例如：
    例子1中，当比较到第7位
    abcdefgab
    abcdefx
    时T当中没有相同的字符，那么j就由7变为1，i不变仍是7，再进行比较
    abcdefgab
          abcdefx

    例子2中，当比较到第6位
    abcabcabc
    abcabx
    时T的1、2位与4、5位相等，那么再比较时j变为3，i不变仍是6
    abcabcabc
       abcabx


    ## KMP模式子串j回溯取值公式：

    定义next数组保存子串T每一个位置比较失败时j值回溯值，next的长度等于T的长度
    next[j] = 0 ，当j=1
            = Max{k | 1<k<j , 且p(1) ... p(k-1) = p(j-k+1) ... p(j-1)} 当集合不为空
            = 1 其他情况

    KMP推导：
    T       abcdex
    j       123456
    next[j] 011111


    T       abcabx
    j       123456
    next[j] 011123
    j=5时，k=2 ， p(k-1) = p(5-k+1) = p(4) = a ,
        若k=3  p(k-1) != p(5-k+1)
        若k=4  p(k-1) != p(5-k+1)
        所以next[j] = 2
    j=6时，k=3 ， p(1) \ p(3-1) = p(6-3+1) \ p(6-1) = ab

    T       ababaaaba
    j       123456789
    next[j] 011234223
    j=4时，k=2， p(2-1) = p(4-2+1) = a
    j=4时，k=3， p(1) / p(3-1) = ab != ba = p(4-3+1) / p(4-1)

    j=5时，k=3， p(1) / p(3-1) = p(5-3+1) / p(5-1) = ab
    j=5时，k=4， p(1) / p(4-2) / p(4-1) = aba != bab = p(5-4+1) / p(5-4+2) / p(5-1)

    j=6时，k=4， p(1) / p(4-2) / p(4-1) = aba = p(6-4+1) / p(6-4+2) / p(6-1)
    j=6时，k=5， p(1) / p(5-3) / p(5-2) / p(5-1) = abab !=  baba = p(6-5+1) / p(6-5+2) / p(6-5+3) / p(6-1)

    可以得到规律 next[j]的值等于从子串1到j-1位置上前缀和后缀相等的字符个数+1，
    例如next[6]=4，ababa 前缀aba等于后缀aba


    T：12123411
    next 1 = 0
    next 2 = 1
    next 3 = 1
    next 4 = 2
    next 5 = 3
    next 6 = 1
    next 7 = 1
    next 8 = 2

    ## KMP模式子串j回溯取值算法

    /*
    * next存储返回的子串j回溯取值
    */
    void get_next(String T, int *next){
        int i,j;
        i=1;
        j=0;
        next[1] = 0;
        while(i<t[0]){
            if(j==0 || T[i] == T[j]){
                ++i;
                ++j;
                next[i] = j;
            }else{
                j = next[j];
            }
        }
    }


    ## 使用KMP计算取子串位置的方法 ， 区别朴素方法 去掉了i的回溯，时间复杂度为O(n+m)，n：主串的长度，m：子串的长度，while循环时间复杂度为O(n),get_next的时间复杂度为O(m)，整个算法时间复杂度为O(n+m)

    int Index_KMP(String S, String T, int pos){
        int i=pos;
        int j=1;
        int next[255];
        get_next(T, next);  --获取T的next数组
        while(i <= S[0] && j<= T[0]){
            if(j==0 || S[i] == T[j]){
                ++i;
                ++j;
            }else{
                j = next[j];
            }
        }
        if(j > T[0]){
            return i-T[0];
        }else{
            return 0;
        }
    }

    ##  KMP模式匹配算法改进

    例子： S = aaaabcde , T = aaaaax , T:next = 012345，当i=5，j=5时 b!=x，之后根据next[5]=4，将判断：i=5,j=4，
    12345678
    aaaabcde
     aaaaax
     123456
    b!=a，根据next[4]=3，将判断：i=5,j=3
    12345678
    aaaabcde
      aaaaax
      123456
    b!=a，根据next[3]=2，将判断：i=5,j=2 ,依次类推直到 判断 i=5 ，j=1
    12345678
    aaaabcde
        aaaaax
        12345678
    b!=a，根据next[1]=0时，根据算法此时i++，j++，将判断i=6，j=1，
    12345678
    aaaabcde
         aaaaax
         12345678
    这次比较结果未知，是有必要的，在此之前的4次比较都通过之前的结果可以预判是肯定失败的，因为T的前5个字符相等，所以可以去掉。
    所以可以用首字符的next值（next[1]）去覆盖后续与他相等字符的next[j]值。

    ## 改良后的next函数

    void get_nextval(String T, int *nextval){
        int i,j;
        i=1;
        j=0;
        nextval[1]=0;
        while(i < T[0]){
            if(j==0 || T[i] == T[j]){
                ++i;
                ++j;
                if(T[i] != T[j]){
                    nextval[i] = j;
                }else{
                    nextval[i] = nextval[j];
                }
            }else{
                j = nextval[j];
            }
        }
    }

    nextval推导：
    T           ababaaaba
    j           123456789
    next[j]     011234223
    nextval[j]  010104210

    j=1:  next[1] = 0  =>nextval[1] = 0
    j=2:  T[2]=b next[2]=1 T[1]=a b!=a  nextval[2] = next[2] = 1
    j=3:  T[3]=a next[3]=1 T[1]=a a=a   nextval[3] = nextval[1] = 0
    j=4:  T[4]=b next[4]=2 T[2]=b b=b   nextval[4] = nextval[2] = 1
    j=5:  T[5]=a next[5]=3 T[3]=a a=a   nextval[5] = nextval[3] = 0
    j=6:  T[6]=a next[6]=4 T[4]=b a!=b  nextval[6] = next[6] = 4
    j=7:  T[7]=a next[7]=2 T[2]=b a!=b  nextval[7] = next[7] = 2
    j=8:  T[8]=b next[8]=2 T[2]=b b=b   nextval[8] = nextval[2] = 1
    j=9:  T[9]=a next[9]=3 T[3]=a a=a   nextval[9] = nextval[3] = 0

    计算nextval值规则：
    获得对应j位置的next值，如果next[j]值对应的T[next[j]]字符与当前T[j] 相等，则nextval[j] = nextval[next[j]]，否则nextval[j]=next[j]

### 树

1.  树

    1）定义
    树是n(n>=0)个结点的有限集。n=0时称为空树。
    在任意一棵非空树中：
    （1）有且仅有一个特定的称为根的结点
    （2）当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2.......Tm，其中每一个集合本身又是一棵树，并且称为根的子树（subTree）

    2）结点分类
    度（Degree）：结点拥有的子树数量称为结点的度
    叶子结点（Leaf）：度为0的结点
    度不为0的结点称为非终端结点或分支结点
    树的度时树内各结点的度的最大值

    3）结点关系
    孩子（Child）：结点的子树的根结点称为该结点的孩子
    双亲（Parent）：相应的该结点为孩子结点的双亲
    兄弟（Sibling）：同一个双亲结点的孩子结点之间互称为兄弟
    祖先：从根结点到该结点所经分支上的所有结点
    子孙：以某结点为根的子树中的任一结点都称为该结点的子孙

    4）名称概念
    结点的层次（Level）：从根开始，根为第一层，根的孩子为第二层，孩子的孩子为第三层
    树的深度（Depth）：树中结点的最大层次数
    森林（Forest）：是m(m>=0)棵互不相交的树的集合

    5）树的数据结构
    常用方法：
    初始化树、返回树的根结点、获取某结点的值、获取结点双亲结点、获取结点的左子结点、获取结点的右兄弟结点、为结点添加子树、删除结点某个子树

    6）树的存储结构

    ## 双亲表示法
    一组连续存储空间存储树的结点，每个结点有一个数据域一个指示双亲结点位置的指针域

    #define MAX_TREE_SIZE 100
    typedef int TElemType;
    typedef struct PTNode{
        TElemType data;
        int parent;  /*双亲结点位置*/
    } PTNode;

    typedef struct{
        PTNode nodes[MAX_TREE_SIZE];
        int r,n;    /*根位置和结点数*/
    } PTree;

    例子：树结构对应的存储表示
    A - B - D - G
              - H
              - I
      - C - E - J
          - F

    下标 data parent
    0   A    -1
    1   B    0
    2   C    0
    3   D    1
    4   E    2
    5   F    2
    6   G    3
    7   H    3
    8   I    3
    9   J    4

    此结构不便于查询孩子结点，可以扩展存储结构增加一个指针记录本结点的右兄弟结点、或者增加一个记录长子的指针域。存储结构的设计取决于运算是否合适、方便时间复杂度等。


    ## 孩子表示法
    每个结点有多个指针域，每个指针指向一棵子树的根结点，这种方法叫做多重链表表示法（即一个结点可以链接到多个结点）。
    由于每个结点的孩子个数不同，有2种设计，1.可以采用最大度数为指针域的数量，缺点是浪费空间。2.每个结点的指针域第一个保存结点度数，后面有和度数相等数量的指针域，缺点是增加了存储长度的空间增加了时间损耗。

    孩子表示法-单链表
    每个结点的孩子结点排列起来以单链表结构存储，n个结点就有n个单链表，叶子结点的单链表为空，n个结点自身组成了一个线性表，使用顺序存储结构存储。

    例子：
    树
    A - B - D - G
              - H
              - I
      - C - E - J
          - F

    孩子表示法存储

            该列为顺序线性表       后面几列是单链表
    下标  [data | firstchild]   [child | next]   [child | next]   [child | next]
    0     A           1      ->     1      2   ->   2       ^
    1     B           3      ->     3      ^
    2     C           4      ->     5      ^
    3     D           6      ->     6      7   ->   7       8 ->    8      ^
    4     E           9      ->     9      ^
    5     F           ^
    6     G           ^
    7     H           ^
    8     I           ^
    9     J           ^

    查找双亲结点比较麻烦可以增加一个指针域保存双亲结点的位置

    ## 孩子兄弟表示法
    存储结点的第一个孩子结点和右兄弟结点的指针

    data | firstchild | rightsib

    有必要时可以再添加一个指针指向双亲结点


    7）二叉树
    定义：是n(n>=0)个结点的有限集合，该集合或者为空集，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

    特点：
        （1）每个结点最多有两棵子树，结点度最大为2
        （2）左子树和右子树是有顺序的不能颠倒
        （3）结点只有一棵树也要区分是左子树或是右子树

    ## 特殊二叉树
    （1）斜树：
        所有结点都只有左子树的二叉树叫左斜树，所有结点都只有右子树的二叉树叫右斜树，统称为斜树
    （2）满二叉树：
        一棵二叉树所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上。
    （3）完全二叉树：
        对一棵具有n个结点的二叉树按层序从左至右编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。

        理解：完全二叉树必须要有同样的深度，结点只能从编号最末端减少但不能减少超过一层的结点

    ## 二叉树的性质
    （1）二叉树的第i层上至多有2^(i-1)个结点(i>=1)
    （2）深度为k的二叉树至多有(2^k)-1个结点(k>=1)
    （3）任意一棵二叉树T，如果叶子结点数为n0，度为2的结点数为n2，则n0=n2+1
    （4）具有n个结点的完全二叉树的深度为[log2n] + 1 (log2n取整数)
        由n=(2^k)-1 推导出：
        n=(2^k)-1 => k=log2(n+1)

        二叉树的结点数一定小于等于同样深度数的满二叉树的结点数，而且一定大于少一层深度的二叉树的结点数 2^(k-1)-1

        2^(k-1)-1 < n <= (2^k)-1
        由于n是整数 n<=(2^k)-1 --> n < 2^k , 2^(k-1)-1 < n --> 2^(k-1) <= n
        2^(k-1) <= n < 2^k  两边取对数 => k-1 <= log2n < k ， k做为度数也是整数，因此
        k=[log2n]+1 (log2n的值取整数)

    （5）对一棵有n个结点的完全二叉树，按层数从上到下，每层从左到右为结点编号，对任一结点i（1<=i<=n），
        有：
        如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲结点是[i/2]
        如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i
        如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1

        例子：
        介于文本文档不方便画图使用如下方式表示树，左边为根右边为叶子结点，从下向上编号，如果向右旋转90度即使正常的树图。
        1   3   7
                6
            2   5
                    10
                4   9
                    8

        7结点的双亲 [7/2] = 3
        4结点 4*2!>10 4*2+1!>10 所以4结点的左孩子为8，右孩子为9
        5结点 5*2!>10 5*2+1>10 所以5结点的左孩子为10，没有右孩子


    ## 二叉树的顺序存储结构
    使用一维数组存储二叉树中的结点
    例如：
    a   c   g
            f
        b   e
                j
            d   i
                h
    下标 1 2 3 4 5 6 7 8 9 10
    存储 a b c d e f g h i j

    非完全二叉树用^表示缺少的结点，如果缺少的结点较多则会导致空间的浪费，所以顺序存储结构一般用于完全二叉树

    ## 二叉链表存储结构 -链式存储结构
    二叉链表：每个结点有一个左孩子指针域、一个数据域、一个右孩子指针域，没有子树的指针域存"^"
    三叉链表：在二叉链表基础上增加一个指向双亲结点的域


    ## 二叉树的遍历
    是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次

    例图：
    A   C   F
            E   I
        B
            D   H
                G

    （1）前序遍历
    规则：若二叉树为空，返回。否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。
    结果：ABDGHCEIF

    （2）中序遍历
    规则：若二叉树为空，返回。否则从根结点开始，先中序遍历左子树，然后是访问根结点，最后中序遍历右子树
    结果：GDHBAEICF

    （3）后序遍历
    规则：若二叉树为空，返回。否则从根结点开始，先后序遍历左子树，然后后序遍历右子树，最后访问根结点。
    结果：GHDBIEFCA

    （4）层序遍历
    规则：若二叉树为空，返回。否则从树的第一层开始，从上到下逐层遍历，每层中从左到右访问每个结点。
    结果：ABCDEFGHI

    计算机处理只有简单的循环、判断的线性处理，遍历方式将树结点变成了某种线性序列供计算机操作。


    ##  遍历算法
    （1）前序遍历算法
    void PreOrderTraverse(BiTree T){
        if(T==NULL)
            return;
        printf("$c", T->data);          /*打印结点数据*/
        PreOrderTraverse(T->lchild);    /*先序遍历左子树*/
        PreOrderTraverse(T->rchild);    /*先序遍历右子树*/
    }

    （2）中序遍历算法
    void PreOrderTraverse(BiTree T){
        if(T==NULL)
            return;
        PreOrderTraverse(T->lchild);    /*先序遍历左子树*/
        printf("$c", T->data);          /*打印结点数据*/
        PreOrderTraverse(T->rchild);    /*先序遍历右子树*/
    }

    （3）后序遍历算法
    void PreOrderTraverse(BiTree T){
        if(T==NULL)
            return;
        PreOrderTraverse(T->lchild);    /*先序遍历左子树*/
        PreOrderTraverse(T->rchild);    /*先序遍历右子树*/
        printf("$c", T->data);          /*打印结点数据*/
    }


    ## 推导
    已知前序和中序遍历序列，可以唯一确定一棵二叉树，
    已知后序和中序遍历序列，可以唯一确定一棵二叉树，
    已知前序和后序遍历序列，不可以唯一确定一棵二叉树。

    例如：
    已知前序遍历序列是：ABCDEF ，中序遍历序列是：CBAEDF，推导后序遍历序列

    （1）根据前序序列：ABCDEF ，得知根结点为A
    （2）根据中序序列，得知 CB 是左子树上的结点，EDF是右子树上的结点
    （3）前序BC得知，B是C的根，中序CB得知C是左子树
    （4）根据前序DEF，得知D是子树的根，根据中序EDF得知E是D的左子树，F是D的右子树

    可以确定二叉树结构是：
    A   D   F
            E
        B
            C

    后序序列：CBEFDA

    ## 二叉树的建立
    将不是满二叉树的二叉树缺少的结点用特殊字符表示例如“#”号，之后根据某种排序获得字符序列，带入建立二叉树的算法。

    /*
    * ch为顺序输入的字符(前序遍历后的字符)
    * T为构造好的二叉树
    */
    void CreateBiTree(BiTree *T){
        TElemType ch;
        scanf("%c", &ch);
        if(ch == '#'){
            *T = NULL;
        }else{
            *T = (BiTree)malloc(sizeof(BiTNode));
            if(!*T){
                exit(OVERFLOW);
            }
            (*T)->data = ch;                /*生成根结点*/
            CreateBiTree(&(*T)->lchild);    /*构造左子树*/
            CreateBiTree(&(*T)->rchild);    /*构造右子树*/
        }
    }


    ## 线索二叉树
    非完全二叉树，采用二叉链表存储结构时会有许多空指针域（左、右子树域为空），浪费了空间。
    为了记录每个结点的前驱和后继结点，可以利用空的指针域指向前驱和后继结点。

    这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）

    对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。线索化的过程就是在遍历的过程中修改空指针的过程。

    结点的存储还要区分左、右子树指针域是存储的左、右子树结点还是前驱和后继结点，所以还要增加2个指针域表示左、右子树指针域存储的是什么，0表示存的是子树、1表示存的是前驱或后继结点。

    ## 线索二叉树结构实现
    typedef enum {Link, Thread} PointerTag;  /*Link==0表示指向左右孩子，Thread==1表示指向前驱或后继*/
    typedef struct BiThrNode{
        TElemType data;
        struct BiThrNode *lchild *rchild;
        PointerTag LTag;
        PointerTag RTag;
    } BiThrNode, *BiThrTree;

    中序遍历线索化的递归函数代码:
    BiThrTree pre;    /*全局变量，指向刚刚访问过的结点*/

    void InThreading(BiThrTree p){
        if(p){
            InThreading(p->lchild);
            if(!p->lchild){         /*当前结点的前驱结点指向pre*/
                p->LTag=Thread;
                p->lchild=pre;
            }
            if(!pre->rchild){       /*前驱结点pre的后继指向当前结点*/
                pre->RTag=Thread;
                pre->rchild=p;
            }
            pre=p;
            InThreading(p->rchild);
        }
    }

    图例：
    A   C   G
            F
        B   E
                J
            D   I
                H

    增加一个头结点，lchild指二叉树的根结点，rchild指向二叉树中序遍历的最后一个结点
    lchild  LTag  data  RTag  rchild
    A       0     null  1     G　    #增加的头结点
    B       0     A     0     C
    D       0     B     0     E
    F       0     C     0     G
    H       0     D     0     I
    J       0     E     1     A
    A       1     F     1     C
    C       1     G     1     null
    null    1     H     1     D
    D       1     I     1     B
    B       1     J     1     E


    ## 中序遍历代码：
    Status InOrderTravers_Thr(BiThrTree T){
        BiThrTree p;
        p = T->lchild;
        while(p!=T){                    /*是否回到了头结点*/
            while(p->LTag==Link){       /*找到树的第一个结点*/
                p = p->lchild;
            }
            printf("%c", p->data);      /*做一些数据处理操作*/
            while(p->RTag==Thread && p->rchild!=T){   /*回到后继结点*/
                p = p->rchild;
                printf("%c", p->data);
            }
            p = p->rchild;              /*进至右子树*/
        }
        return OK;
    }

    时间复杂度为O(n)
    如果二叉树需要经常遍历或查找结点时需要某种顺序的前驱和后继，那么采用线索二叉链表存储结构是很好的选择

    ##  树、森林和二叉树的转换
    1.  树转二叉树
    步骤：
    （1）加线，在所有兄弟结点之间加一条连线
    （2）去线，对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点的连线
    （3）层次调整，以树根结点为轴心，将树顺时旋转一定的角度，使之结构层次分明。兄弟结点旋转后变为右子结点
    例如：
    A   D   J
            I
        C   H
        B   G
            F
            E
    加线:
    A   D   J
        |   |
        |   I
        C   H
        |
        B   G
            |
            F
            |
            E
    去线、旋转
    A
        B   C   D
                    I   J
                H
            E   F   G

    2. 森林转二叉树
    森林是由若干棵树组成的，转换步骤：
    （1）将每棵树转为二叉树
    （2）第一棵二叉树不动，后面的每棵二叉树的根结点做为上一棵树根结点的右子结点

    3. 二叉树转换为树
    是树转换为二叉树的逆过程
    步骤：
    （1）加线，若某个结点的左孩子结点存在，则将这个左孩子的右孩子以及右孩子的右孩子的右孩子....等若干个右孩子都做为当前结点的孩子结点，用线与这些右孩子结点连接起来
    （2）去线，删除原二叉树中所有结点与其右孩子孩子结点的连线
    （3）层次调整，使之结构层次分明

    4. 二叉树转森林
    先判断二叉树有没有右孩子，若有则可以转为森林，没有只能转为树
    步骤：
    （1）从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查分离后的二叉树，重复同样操作删除右孩子的连线，直到所有分离出来的二叉树根结点上没有右孩子结点。
    （2）之后在将每棵二叉树转为树

    5. 树与森林的遍历
    # 遍历树的两种方式：
    （1）先根遍历，即先访问树的根结点，然后依次遍历根的每棵子树
    （2）后根遍历，先依次遍历每棵子树，然后再访问根结点。
    例如：
    A   D
            G
        C
        B   F
            E
    先根遍历：ABEFCDG   后根遍历：EFBCGDA

    # 遍历森林的两种方式：
    （1）前序遍历：用先根遍历方法遍历每棵树
    （2）后序遍历：有后根遍历方法遍历每棵树
    例如：
    树1
    A   D
        C
        B

    树2
    E   F

    树3
    G   I
        H   J

    前序遍历：ABCDEFGHJI  后序遍历：BCDAFEJHIG


    ## 霍夫曼树
    叶子结点带权的二叉树：将二叉树每个叶子结点加上权值

    路径长度：从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数称做路径长度。
    树的路径长度：从根到每一个结点的路径长度之和

    带权路径长度：路径长度与结点权值的乘积。
    树的带权路径长度：为树中所有叶子结点的带权路径长度之和。

    霍夫曼树：假设有n个权值{w1,w2,w3....wn}，构造一棵有n个叶子结点的二叉树，每个叶子结点分配一个权值wk，每个叶子的路径长度为lk，则其中带权路径长度WPL最小的二叉树称做霍夫曼树或最优二叉树

    例如：
    二叉树1
    null   null   null   null   E-10
                                D-30
                         C-40
                  B-15
           A-5

    WPL= 1*5 + 2*15 + 3*40 + 4*10 + 4*30 = 315

    二叉树2
    null   null   E-10
                  D-30
           null   C-40
                  null   B-15
                         A-5
    WPL= 2*10 + 2*30 + 2*40 + 3*15 + 3*5 = 220

    二叉树2比二叉树1比较次数少了大概三分之一

    ## 霍夫曼树构建方法
    （1）将所有权值的叶子结点从小到大排列成一个有序序列，A5、E10、B15、C40、D30
    （2）取前两个最小的结点做为一个新结点N1的左和右孩子，N1的权等于A+B的权值20，将N1替换A和B结点放回有序序列中，重新按大小排序。
    （3）重复步骤2直到序列中只有一个结点，即时霍夫曼树的根结点。

    ## 霍夫曼编码
    为了减少数据传输优化数据大小
    例子：
    文字内容为：BADCADFEED
    使用二进制编码 A=000, B=001, C=010, D=011, E=100, F=101
    编码后的数据：001000011010000011101100100011

    由于有些字母是常用的出现率高，比如 A 27, B 8, C 15, D 15, E 30, F 5 ，那么我们可以用霍夫曼树来规划它们。
    (1)F5 B8 C15 D15 A27 E30
    N1 = F5 + B8 = 13

    (2)N1-13 C15 D15 A27 E30
    N2 = N1 + C = 28

    (3)D15 A27 N2-28 E30
    N3 = D + A = 42

    (4)N2-28 E30 N3-42
    N4 = N2 + E = 58

    (5)N3-42 N4-58
    N5 = N3 + N4 = 100

    N5    N4    E-30
                N2    C-15
                      N1    B-8
                            F-5
          N3    A27
                D15

    将左孩子分支标记0，右孩子分枝标记1
    N5  -1-  N4  -1-  E-30
                 -0-  N2  -1-  C-15
                          -0-  N1  -1-  B-8
                                   -0-  F-5
        -0-  N3  -1-  A27
                 -0-  D15

    用结点路径上的0和1表示字母的编码
    A=01, B=1001, C=101, D=00, E=11, F=1000
    BADCADFEED
    新的编码：10010100101011000111100

    比原编码长度短了，而且这种长短不一的编码没有重叠前缀的问题，例如110 、1100 这样2个不能区分截取长度的问题，解码时需要用相同霍夫曼编码规则解码。

    # 霍夫曼编码定义：
    设需要编码的字符集为{d1, d2, d3...... dn}，各个字符在电文中出现的次数或频率集合为{w1, w2, w3...... wn}，以字符d1, d3 ....dn 作为叶子结点，以w1, ...wn 作为相应叶子结点的权值来构造一棵霍夫曼树。规定霍夫曼左分分代表0，➡️分支代表1，则从根结点到叶子结点所经过的路径分支组成的01序列为该结点对应的字符的编码。










