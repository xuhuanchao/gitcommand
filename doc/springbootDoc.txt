15. Configuration Classes
Spring Boot favors Java-based configuration. Although it is possible to use SpringApplication with XML sources, we generally recommend that your primary source be a single @Configuration class. Usually the class that defines the main method is a good candidate as the primary @Configuration.


翻译：
spring boot支持使用基于java的配置。尽管可以使用xml资源文件在spring应用中，我们一般推荐你的主要资源是使用一个标注了@Configuration的class。 通常把这个class定义在使用@Configuration注解的main方法是一个好的候选方式。


Many Spring configuration examples have been published on the Internet that use XML configuration. If possible, always try to use the equivalent Java-based configuration. Searching for Enable* annotations can be a good starting point.

翻译：
很多已经发布在internet的spring应用案例使用xml进行配置。如果可能的话，总是尝试使用相同的基于java的配置。搜索 Enable*开头的注解是一个好的开始点。


15.1 Importing Additional Configuration Classes
You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes. Alternatively, you can use @ComponentScan to automatically pick up all Spring components, including @Configuration classes.

翻译：
你不需要将所有@Configuration配置放到一个class中。 @Import注释可以用来引入额外的配置类。 二选一，你可以使用@ComponentScan 自动检查所有包含@Configuration的组件


15.2 Importing XML Configuration
If you absolutely must use XML based configuration, we recommend that you still start with a @Configuration class. You can then use an @ImportResource annotation to load XML configuration files.

翻译：
如果你非要使用基于xml的配置，我们推荐你仍然以一个@Configuration类做起始。你可以在这个类中使用@ImportResource注解去读取xml配置文件



16. Auto-configuration
Spring Boot auto-configuration attempts to automatically configure your Spring application based on the jar dependencies that you have added. For example, if HSQLDB is on your classpath, and you have not manually configured any database connection beans, then Spring Boot auto-configures an in-memory database.

You need to opt-in to auto-configuration by adding the @EnableAutoConfiguration or @SpringBootApplication annotations to one of your @Configuration classes.

[Tip]
You should only ever add one @SpringBootApplication or @EnableAutoConfiguration annotation. We generally recommend that you add one or the other to your primary @Configuration class only.


翻译：
spring boot 会自动尝试配置你添加到应用的依赖jar包。例如，如果HSQLDB在你的classpath路径，你不需要手动配置任何数据库连接bean，spring boot会自动配置一个内存数据库。

你需要在@Configuration 的类上,选择添加@EnableAutoConfiguration 或 @SpringBootApplication 注解来启用自动化配置。

提示
你应该总是添加@EnableAutoConfiguration 或 @SpringBootApplication注解。 我们一般推荐你将他们添加到主@Configuration类上。


16.1 Gradually Replacing Auto-configuration
Auto-configuration is non-invasive. At any point, you can start to define your own configuration to replace specific parts of the auto-configuration. For example, if you add your own DataSource bean, the default embedded database support backs away.

If you need to find out what auto-configuration is currently being applied, and why, start your application with the --debug switch. Doing so enables debug logs for a selection of core loggers and logs a conditions report to the console.

翻译：
逐步的取代自动配置
自动配置是非入侵的。在任意时刻你可以定义你自己的配置来替代自动配置中的某一部分。 例如，如果你添加自己的数据源bean，那么默认的内置数据源支持将退出。

如果你需要找到当前应用的自动配置和为什么有这些自动配置的话，使用debug模式启动应用。这样做可以在选择的日志记录器和日志上启动debug日志，并报告在控制台。


16.2 Disabling Specific Auto-configuration Classes
If you find that specific auto-configuration classes that you do not want are being applied, you can use the exclude attribute of @EnableAutoConfiguration to disable them, as shown in the following example:

import org.springframework.boot.autoconfigure.*;
import org.springframework.boot.autoconfigure.jdbc.*;
import org.springframework.context.annotation.*;

@Configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}
If the class is not on the classpath, you can use the excludeName attribute of the annotation and specify the fully qualified name instead. Finally, you can also control the list of auto-configuration classes to exclude by using the spring.autoconfigure.exclude property.

[Tip]
You can define exclusions both at the annotation level and by using the property.

翻译：
16.2 禁用某些自动配置类
如果你发现有些自动配置类是你不想使用的，你可以使用@EnableAutoConfiguration注解的excludes属性去禁用它们，例子如下：

如果这个类不在classpath上，你可以使用excludeName属性通过给出类的全名称来禁用它。 最后，你也可以定义不想自动配置的类列表，通过使用spring.autoconfigure.exclude 配置属性

提示
你可以同时通过注解和属性文件定义要排除的自动配置



17. Spring Beans and Dependency Injection
You are free to use any of the standard Spring Framework techniques to define your beans and their injected dependencies. For simplicity, we often find that using @ComponentScan (to find your beans) and using @Autowired (to do constructor injection) works well.

If you structure your code as suggested above (locating your application class in a root package), you can add @ComponentScan without any arguments. All of your application components (@Component, @Service, @Repository, @Controller etc.) are automatically registered as Spring Beans.

The following example shows a @Service Bean that uses constructor injection to obtain a required RiskAssessor bean:

package com.example.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class DatabaseAccountService implements AccountService {

	private final RiskAssessor riskAssessor;

	@Autowired
	public DatabaseAccountService(RiskAssessor riskAssessor) {
		this.riskAssessor = riskAssessor;
	}

	// ...

}
If a bean has one constructor, you can omit the @Autowired, as shown in the following example:

@Service
public class DatabaseAccountService implements AccountService {

	private final RiskAssessor riskAssessor;

	public DatabaseAccountService(RiskAssessor riskAssessor) {
		this.riskAssessor = riskAssessor;
	}

	// ...

}
[Tip]
Notice how using constructor injection lets the riskAssessor field be marked as final, indicating that it cannot be subsequently changed.

翻译：
你可以免费使用任意标准的spring 框架技巧来定义你的bean和注入依赖。 简单的说，我们通常发现使用@ComponentScan来发现bean,使用@Autowired注解来构建注入的机制运行良好。

如果你按照下面建议构建你的代码（将应用程序class放置到根包下），你可以添加@ComponentScan注解不适用任何参数。你的所有应用组件（@Component, @Service, @Repository, @Controller）会自动注册为spring bean

下面的例子是展示使用@Service 注解的Bean ,在构造方法中注入RiskAssessor Bean。  如果Bean只有一个构造方法，你可以省略@Autowired。

注意
如何使用构造方法注入，让riskAssessor字段使用final，表示他不能被随后修改。






#################### 






23.5 Application Events and Listeners
In addition to the usual Spring Framework events, such as ContextRefreshedEvent, a
SpringApplication sends some additional application events.
Note
Some events are actually triggered before the ApplicationContext is created,
so you cannot register a listener on those as a @Bean. You can
register them with the SpringApplication.addListeners(…) method or the
SpringApplicationBuilder.listeners(…) method.

If you want those listeners to be registered automatically, regardless of the way the application is
created, you can add a META-INF/spring.factories file to your project and reference your
listener(s) by using the org.springframework.context.ApplicationListener key, as
shown in the following example:
org.springframework.context.ApplicationListener=com.example.project.MyListener

Application events are sent in the following order, as your application runs:
1. An ApplicationStartingEvent is sent at the start of a run but before any processing, except
for the registration of listeners and initializers.
2. An ApplicationEnvironmentPreparedEvent is sent when the Environment to be used in the
context is known but before the context is created.
3. An ApplicationPreparedEvent is sent just before the refresh is started but after bean definitions
have been loaded.
4. An ApplicationStartedEvent is sent after the context has been refreshed but before any
application and command-line runners have been called.
5. An ApplicationReadyEvent is sent after any application and command-line runners have been
called. It indicates that the application is ready to service requests.
6. An ApplicationFailedEvent is sent if there is an exception on startup.

Tip
You often need not use application events, but it can be handy to know that they exist. Internally,
Spring Boot uses events to handle a variety of tasks.

Application events are sent by using Spring Framework’s event publishing mechanism. Part of this
mechanism ensures that an event published to the listeners in a child context is also published
to the listeners in any ancestor contexts. As a result of this, if your application uses a hierarchy
of SpringApplication instances, a listener may receive multiple instances of the same type of
application event.


To allow your listener to distinguish between an event for its context and an event for a
descendant context, it should request that its application context is injected and then compare
the injected context with the context of the event. The context can be injected by implementing
ApplicationContextAware or, if the listener is a bean, by using @Autowired.

翻译：
23.5 应用事件和监听
除了通常的spring framework事件例如ContextRefreshedEvent，spring还发送一个附加的应用事件

注意
一些事件实际上在spring上下文被创建前触发，所以你不能通过@Bean方式注册一个监听。你可以通过SpringApplication.addListeners(…) 或者SpringApplicationBuilder.listeners(…)方法注册监听。

如果你想自动注册监听，不管应用程序是否创建，你可以添加META-INF/spring.factories文件到你的工程并且使用 org.springframework.context.ApplicationListener key 去关联监听，例如：
org.springframework.context.ApplicationListener=com.example.project.MyListener

应用事件按照以下顺序发送：
1. ApplicationStartingEvent： 应用程序启动前没有任何处理时（除了注册监听和初始化代码）
2. ApplicationEnvironmentPreparedEvent：环境（Enviroment）已初始化并将被应用在上下文（context），但是context还未创建时
3. ApplicationPreparedEvent：上下文更新未生效，但是bean定义已经加载
4. ApplicationStartedEvent： 上下文更新已经生效，但是 command-line还未执行
5. ApplicationReadyEvent：command-line已经执行完成，表明应用已经开始处理请求
6. ApplicationFailedEvent：启动抛出异常时

提示：
你不会经常使用应用事件，但是知道它们的存在会带来方便。在内部Spring Boot使用事件去处理各种任务。

应用事件通过spring framework的事件发布机制来发送。这部分机制确保一个事件既发布给子上下文的监听也发布给任何父上下文的监听。这样处理的结构就是如果你的应用使用了层级springapplication实例，那么一个监听可以接收到多个实例发送的事件

为了让你的监听区分一个事件是他自己上下文的事件还是它子上下文中的事件，可以通过比较监听所在的上下文和事件所在的上下文来确定。上下文可以通过ApplicationContextAware来进行注入，如果listener是一个bean，应该使用@Autowired来注解




23.6 Web Environment
A SpringApplication attempts to create the right type of ApplicationContext on your behalf.
The algorithm used to determine a WebApplicationType is fairly simple:
• If Spring MVC is present, an AnnotationConfigServletWebServerApplicationContext is
used
• If Spring MVC is not present and Spring WebFlux is present, an
AnnotationConfigReactiveWebServerApplicationContext is used
• Otherwise, AnnotationConfigApplicationContext is used
This means that if you are using Spring MVC and the new WebClient from Spring WebFlux in
the same application, Spring MVC will be used by default. You can override that easily by calling
setWebApplicationType(WebApplicationType).
It is also possible to take complete control of the ApplicationContext type that is used by calling
setApplicationContextClass(…).
Tip
It is often desirable to call setWebApplicationType(WebApplicationType.NONE) when
using SpringApplication within a JUnit test.

翻译：
一个spring应用程序总代代表你尝试去创建正确的ApplicationContext 上下文类型。决定web应用上下文的算法相当的简单：
* 如果spring mvc存在，使用AnnotationConfigServletWebServerApplicationContext
* 如果spring mvc不存在，spring webflux存在，使用 AnnotationConfigReactiveWebServerApplicationContext
* 其他情况使用 AnnotationConfigApplicationContext
这意味着如果你使用了spring mvc和 spring webflux 在同一个应用里， spring mvc将被默认使用。你可以覆盖上下文类型通过setWebApplicationType()方法。 也可以通过setApplicationContextClass()完全控制上下文类型。

提示：
在JUnittest时 通过使用setWebApplicationType(WebApplicationType.NONE)



23.7 Accessing Application Arguments
If you need to access the application arguments that were passed to SpringApplication.run(…
), you can inject a org.springframework.boot.ApplicationArguments bean. The
ApplicationArguments interface provides access to both the raw String[] arguments as well as
parsed option and non-option arguments, as shown in the following example:
import org.springframework.boot.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.stereotype.*;
@Component
public class MyBean {
@Autowired
public MyBean(ApplicationArguments args) {
boolean debug = args.containsOption("debug");
List<String> files = args.getNonOptionArgs();
// if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
}
}
Tip
Spring Boot also registers a CommandLinePropertySource with the Spring Environment.
This lets you also inject single application arguments by using the @Value annotation.


翻译：
如果你需要访问SpringApplication.run(…) 传递进来的参数，你可以注入org.springframework.boot.ApplicationArguments Bean来获取。ApplicationArguments接口提供了访问未加工的String[]参数，也可以访问解析后的选项和非选项参数



23.8 Using the ApplicationRunner or CommandLineRunner
If you need to run some specific code once the SpringApplication has started, you can implement
the ApplicationRunner or CommandLineRunner interfaces. Both interfaces work in the same way
and offer a single run method, which is called just before SpringApplication.run(…) completes.
The CommandLineRunner interfaces provides access to application arguments as a simple string
array, whereas the ApplicationRunner uses the ApplicationArguments interface discussed
earlier. The following example shows a CommandLineRunner with a run method:
import org.springframework.boot.*;
import org.springframework.stereotype.*;
@Component
public class MyBean implements CommandLineRunner {
public void run(String... args) {
// Do something...
}
}
If several CommandLineRunner or ApplicationRunner beans are defined that must be called in a
specific order, you can additionally implement the org.springframework.core.Ordered interface
or use the org.springframework.core.annotation.Order annotation.


翻译：
23.8 使用ApplicationRunner or CommandLineRunner
如果你想在spring应用程序启动后执行一些代码，你可以实现ApplicationRunner or CommandLineRunner接口。这2个接口有同样的工作方式都提供了一个run方法，当SpringApplication.run(…)方法完成前会被调用。CommandLineRunner接口提供了一个String数组访问应用参数，然后AppliactionRunner使用ApplicationArguments接口提供，如前面介绍过的方式。



23.9 Application Exit
Each SpringApplication registers a shutdown hook with the JVM to ensure that the
ApplicationContext closes gracefully on exit. All the standard Spring lifecycle callbacks (such as
the DisposableBean interface or the @PreDestroy annotation) can be used.
In addition, beans may implement the org.springframework.boot.ExitCodeGenerator
interface if they wish to return a specific exit code when SpringApplication.exit() is called. This
exit code can then be passed to System.exit() to return it as a status code, as shown in the following
example:
@SpringBootApplication
public class ExitCodeApplication {
@Bean
public ExitCodeGenerator exitCodeGenerator() {
return () -> 42;
}
public static void main(String[] args) {
System.exit(SpringApplication
.exit(SpringApplication.run(ExitCodeApplication.class, args)));
}
}
Also, the ExitCodeGenerator interface may be implemented by exceptions. When such an exception
is encountered, Spring Boot returns the exit code provided by the implemented getExitCode()
method.


翻译：
23.9 应用退出
每个spring应用会在jvm注册一个关闭钩子确保在jvm退出是可以优雅的关闭上下文。所有的spring标准声明周期的回调方法都可以使用（例如：DisposableBean接口 或者 @PreDestroy 注解）。另外，可以实现org.springframework.boot.ExitCodeGenerator接口，来实现当SpringApplication.exit() 调用后返回特殊的code



23.10 Admin Features
It is possible to enable admin-related features for the application by
specifying the spring.application.admin.enabled property. This exposes the
SpringApplicationAdminMXBean on the platform MBeanServer. You could use this feature to
administer your Spring Boot application remotely. This feature could also be useful for any service
wrapper implementation.
Tip
If you want to know on which HTTP port the application is running, get the property with a key
of local.server.port.
Caution
Take care when enabling this feature, as the MBean exposes a method to shutdown the
application.


翻译：
23.10 管理员特性
通过特殊的spring.application.admin.enabled 属性可以使用管理员特性。这显示SpringApplicationAdminMXBean在MBeanServer平台上。你可以使用这些特性在远端管理你的spring boot应用。这个特性对任意服务的封装实现也是很有用的。

提示：
如果你想知道那个http端口被应用使用，通过local.server.port属性获得。

小心：
注意启用这个特性，当MBean显示一个关闭应用的方法时


24. Externalized Configuration
Spring Boot lets you externalize your configuration so that you can work with the same application
code in different environments. You can use properties files, YAML files, environment variables, and
command-line arguments to externalize configuration. Property values can be injected directly into your
beans by using the @Value annotation, accessed through Spring’s Environment abstraction, or be
bound to structured objects through @ConfigurationProperties.
Spring Boot uses a very particular PropertySource order that is designed to allow sensible overriding
of values. Properties are considered in the following order:
1. Devtools global settings properties on your home directory (~/.spring-bootdevtools.
properties when devtools is active).
2. @TestPropertySource annotations on your tests.
3. @SpringBootTest#properties annotation attribute on your tests.
4. Command line arguments.
5. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable
or system property).
6. ServletConfig init parameters.
7. ServletContext init parameters.
8. JNDI attributes from java:comp/env.
9. Java System properties (System.getProperties()).
10.OS environment variables.
11.A RandomValuePropertySource that has properties only in random.*.
12.Profile-specific application properties outside of your packaged jar (application-
{profile}.properties and YAML variants).
13.Profile-specific application properties packaged inside your jar (application-
{profile}.properties and YAML variants).
14.Application properties outside of your packaged jar (application.properties and YAML
variants).
15.Application properties packaged inside your jar (application.properties and YAML variants).
16.@PropertySource annotations on your @Configuration classes.
17.Default properties (specified by setting SpringApplication.setDefaultProperties).
To provide a concrete example, suppose you develop a @Component that uses a name property, as
shown in the following example:
import org.springframework.stereotype.*;
import org.springframework.beans.factory.annotation.*;
Spring Boot Reference Guide
2.0.3.RELEASE Spring Boot 60
@Component
public class MyBean {
@Value("${name}")
private String name;
// ...
}
On your application classpath (for example, inside your jar) you can have an
application.properties file that provides a sensible default property value for name. When
running in a new environment, an application.properties file can be provided outside of your jar
that overrides the name. For one-off testing, you can launch with a specific command line switch (for
example, java -jar app.jar --name="Spring").
Tip
The SPRING_APPLICATION_JSON properties can be supplied on the command line with an
environment variable. For example, you could use the following line in a UN*X shell:
$ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar
In the preceding example, you end up with acme.name=test in the Spring Environment. You
can also supply the JSON as spring.application.json in a System property, as shown in
the following example:
$ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar
You can also supply the JSON by using a command line argument, as shown in the following
example:
$ java -jar myapp.jar --spring.application.json='{"name":"test"}'
You can also supply the JSON as a JNDI variable, as follows: java:comp/env/
spring.application.json.






















	






