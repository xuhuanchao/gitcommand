15. Configuration Classes
Spring Boot favors Java-based configuration. Although it is possible to use SpringApplication with XML sources, we generally recommend that your primary source be a single @Configuration class. Usually the class that defines the main method is a good candidate as the primary @Configuration.


翻译：
spring boot支持使用基于java的配置。尽管可以使用xml资源文件在spring应用中，我们一般推荐你的主要资源是使用一个标注了@Configuration的class。 通常把这个class定义在使用@Configuration注解的main方法是一个好的候选方式。


Many Spring configuration examples have been published on the Internet that use XML configuration. If possible, always try to use the equivalent Java-based configuration. Searching for Enable* annotations can be a good starting point.

翻译：
很多已经发布在internet的spring应用案例使用xml进行配置。如果可能的话，总是尝试使用相同的基于java的配置。搜索 Enable*开头的注解是一个好的开始点。


15.1 Importing Additional Configuration Classes
You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes. Alternatively, you can use @ComponentScan to automatically pick up all Spring components, including @Configuration classes.

翻译：
你不需要将所有@Configuration配置放到一个class中。 @Import注释可以用来引入额外的配置类。 二选一，你可以使用@ComponentScan 自动检查所有包含@Configuration的组件


15.2 Importing XML Configuration
If you absolutely must use XML based configuration, we recommend that you still start with a @Configuration class. You can then use an @ImportResource annotation to load XML configuration files.

翻译：
如果你非要使用基于xml的配置，我们推荐你仍然以一个@Configuration类做起始。你可以在这个类中使用@ImportResource注解去读取xml配置文件



16. Auto-configuration
Spring Boot auto-configuration attempts to automatically configure your Spring application based on the jar dependencies that you have added. For example, if HSQLDB is on your classpath, and you have not manually configured any database connection beans, then Spring Boot auto-configures an in-memory database.

You need to opt-in to auto-configuration by adding the @EnableAutoConfiguration or @SpringBootApplication annotations to one of your @Configuration classes.

[Tip]
You should only ever add one @SpringBootApplication or @EnableAutoConfiguration annotation. We generally recommend that you add one or the other to your primary @Configuration class only.


翻译：
spring boot 会自动尝试配置你添加到应用的依赖jar包。例如，如果HSQLDB在你的classpath路径，你不需要手动配置任何数据库连接bean，spring boot会自动配置一个内存数据库。

你需要在@Configuration 的类上,选择添加@EnableAutoConfiguration 或 @SpringBootApplication 注解来启用自动化配置。

提示
你应该总是添加@EnableAutoConfiguration 或 @SpringBootApplication注解。 我们一般推荐你将他们添加到主@Configuration类上。


16.1 Gradually Replacing Auto-configuration
Auto-configuration is non-invasive. At any point, you can start to define your own configuration to replace specific parts of the auto-configuration. For example, if you add your own DataSource bean, the default embedded database support backs away.

If you need to find out what auto-configuration is currently being applied, and why, start your application with the --debug switch. Doing so enables debug logs for a selection of core loggers and logs a conditions report to the console.

翻译：
逐步的取代自动配置
自动配置是非入侵的。在任意时刻你可以定义你自己的配置来替代自动配置中的某一部分。 例如，如果你添加自己的数据源bean，那么默认的内置数据源支持将退出。

如果你需要找到当前应用的自动配置和为什么有这些自动配置的话，使用debug模式启动应用。这样做可以在选择的日志记录器和日志上启动debug日志，并报告在控制台。


16.2 Disabling Specific Auto-configuration Classes
If you find that specific auto-configuration classes that you do not want are being applied, you can use the exclude attribute of @EnableAutoConfiguration to disable them, as shown in the following example:

import org.springframework.boot.autoconfigure.*;
import org.springframework.boot.autoconfigure.jdbc.*;
import org.springframework.context.annotation.*;

@Configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}
If the class is not on the classpath, you can use the excludeName attribute of the annotation and specify the fully qualified name instead. Finally, you can also control the list of auto-configuration classes to exclude by using the spring.autoconfigure.exclude property.

[Tip]
You can define exclusions both at the annotation level and by using the property.

翻译：
16.2 禁用某些自动配置类
如果你发现有些自动配置类是你不想使用的，你可以使用@EnableAutoConfiguration注解的excludes属性去禁用它们，例子如下：

如果这个类不在classpath上，你可以使用excludeName属性通过给出类的全名称来禁用它。 最后，你也可以定义不想自动配置的类列表，通过使用spring.autoconfigure.exclude 配置属性

提示
你可以同时通过注解和属性文件定义要排除的自动配置



17. Spring Beans and Dependency Injection
You are free to use any of the standard Spring Framework techniques to define your beans and their injected dependencies. For simplicity, we often find that using @ComponentScan (to find your beans) and using @Autowired (to do constructor injection) works well.

If you structure your code as suggested above (locating your application class in a root package), you can add @ComponentScan without any arguments. All of your application components (@Component, @Service, @Repository, @Controller etc.) are automatically registered as Spring Beans.

The following example shows a @Service Bean that uses constructor injection to obtain a required RiskAssessor bean:

package com.example.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class DatabaseAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    @Autowired
    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }

    // ...

}
If a bean has one constructor, you can omit the @Autowired, as shown in the following example:

@Service
public class DatabaseAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }

    // ...

}
[Tip]
Notice how using constructor injection lets the riskAssessor field be marked as final, indicating that it cannot be subsequently changed.

翻译：
你可以免费使用任意标准的spring 框架技巧来定义你的bean和注入依赖。 简单的说，我们通常发现使用@ComponentScan来发现bean,使用@Autowired注解来构建注入的机制运行良好。

如果你按照下面建议构建你的代码（将应用程序class放置到根包下），你可以添加@ComponentScan注解不适用任何参数。你的所有应用组件（@Component, @Service, @Repository, @Controller）会自动注册为spring bean

下面的例子是展示使用@Service 注解的Bean ,在构造方法中注入RiskAssessor Bean。  如果Bean只有一个构造方法，你可以省略@Autowired。

注意
如何使用构造方法注入，让riskAssessor字段使用final，表示他不能被随后修改。





18. Using the @SpringBootApplication Annotation
Many Spring Boot developers like their apps to use auto-configuration, component scan and be able to define extra configuration on their "application class". A single @SpringBootApplication annotation can be used to enable those three features, that is:
• @EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism
• @ComponentScan: enable @Component scan on the package where the application is located (see
the best practices)
• @Configuration: allow to register extra beans in the context or import additional configuration
classes
The @SpringBootApplication annotation is equivalent to using @Configuration, @EnableAutoConfiguration, and @ComponentScan with their default attributes, as shown in the following example:

package com.example.myapplication;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan
public class Application {
public static void main(String[] args) { SpringApplication.run(Application.class, args);
} }
 Note
@SpringBootApplication also provides aliases to customize the attributes of @EnableAutoConfiguration and @ComponentScan.
Note
None of these features are mandatory and you may chose to replace this single annotation by any of the features that it enables. For instance, you may not want to use component scan in your application:

package com.example.myapplication;
import org.springframework.boot.SpringApplication;
import org.springframework.context.annotation.ComponentScan import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import;
@Configuration
@EnableAutoConfiguration
@Import({ MyConfig.class, MyAnotherConfig.class }) public class Application {
public static void main(String[] args) { SpringApplication.run(Application.class, args);
} }
   2.0.3.RELEASE Spring Boot 38
Spring Boot Reference Guide
    In this example, Application is just like any other Spring Boot application except that @Component-annotated classes are not detected automatically and the user-defined beans are imported explicitly (see @Import).



翻译：





####################






23.5 Application Events and Listeners
In addition to the usual Spring Framework events, such as ContextRefreshedEvent, a
SpringApplication sends some additional application events.
Note
Some events are actually triggered before the ApplicationContext is created,
so you cannot register a listener on those as a @Bean. You can
register them with the SpringApplication.addListeners(…) method or the
SpringApplicationBuilder.listeners(…) method.

If you want those listeners to be registered automatically, regardless of the way the application is
created, you can add a META-INF/spring.factories file to your project and reference your
listener(s) by using the org.springframework.context.ApplicationListener key, as
shown in the following example:
org.springframework.context.ApplicationListener=com.example.project.MyListener

Application events are sent in the following order, as your application runs:
1. An ApplicationStartingEvent is sent at the start of a run but before any processing, except
for the registration of listeners and initializers.
2. An ApplicationEnvironmentPreparedEvent is sent when the Environment to be used in the
context is known but before the context is created.
3. An ApplicationPreparedEvent is sent just before the refresh is started but after bean definitions
have been loaded.
4. An ApplicationStartedEvent is sent after the context has been refreshed but before any
application and command-line runners have been called.
5. An ApplicationReadyEvent is sent after any application and command-line runners have been
called. It indicates that the application is ready to service requests.
6. An ApplicationFailedEvent is sent if there is an exception on startup.

Tip
You often need not use application events, but it can be handy to know that they exist. Internally,
Spring Boot uses events to handle a variety of tasks.

Application events are sent by using Spring Framework’s event publishing mechanism. Part of this
mechanism ensures that an event published to the listeners in a child context is also published
to the listeners in any ancestor contexts. As a result of this, if your application uses a hierarchy
of SpringApplication instances, a listener may receive multiple instances of the same type of
application event.


To allow your listener to distinguish between an event for its context and an event for a
descendant context, it should request that its application context is injected and then compare
the injected context with the context of the event. The context can be injected by implementing
ApplicationContextAware or, if the listener is a bean, by using @Autowired.

翻译：
23.5 应用事件和监听
除了通常的spring framework事件例如ContextRefreshedEvent，spring还发送一个附加的应用事件

注意
一些事件实际上在spring上下文被创建前触发，所以你不能通过@Bean方式注册一个监听。你可以通过SpringApplication.addListeners(…) 或者SpringApplicationBuilder.listeners(…)方法注册监听。

如果你想自动注册监听，不管应用程序是否创建，你可以添加META-INF/spring.factories文件到你的工程并且使用 org.springframework.context.ApplicationListener key 去关联监听，例如：
org.springframework.context.ApplicationListener=com.example.project.MyListener

应用事件按照以下顺序发送：
1. ApplicationStartingEvent： 应用程序启动前没有任何处理时（除了注册监听和初始化代码）
2. ApplicationEnvironmentPreparedEvent：环境（Enviroment）已初始化并将被应用在上下文（context），但是context还未创建时
3. ApplicationPreparedEvent：上下文更新未生效，但是bean定义已经加载
4. ApplicationStartedEvent： 上下文更新已经生效，但是 command-line还未执行
5. ApplicationReadyEvent：command-line已经执行完成，表明应用已经开始处理请求
6. ApplicationFailedEvent：启动抛出异常时

提示：
你不会经常使用应用事件，但是知道它们的存在会带来方便。在内部Spring Boot使用事件去处理各种任务。

应用事件通过spring framework的事件发布机制来发送。这部分机制确保一个事件既发布给子上下文的监听也发布给任何父上下文的监听。这样处理的结构就是如果你的应用使用了层级springapplication实例，那么一个监听可以接收到多个实例发送的事件

为了让你的监听区分一个事件是他自己上下文的事件还是它子上下文中的事件，可以通过比较监听所在的上下文和事件所在的上下文来确定。上下文可以通过ApplicationContextAware来进行注入，如果listener是一个bean，应该使用@Autowired来注解




23.6 Web Environment
A SpringApplication attempts to create the right type of ApplicationContext on your behalf.
The algorithm used to determine a WebApplicationType is fairly simple:
• If Spring MVC is present, an AnnotationConfigServletWebServerApplicationContext is
used
• If Spring MVC is not present and Spring WebFlux is present, an
AnnotationConfigReactiveWebServerApplicationContext is used
• Otherwise, AnnotationConfigApplicationContext is used
This means that if you are using Spring MVC and the new WebClient from Spring WebFlux in
the same application, Spring MVC will be used by default. You can override that easily by calling
setWebApplicationType(WebApplicationType).
It is also possible to take complete control of the ApplicationContext type that is used by calling
setApplicationContextClass(…).
Tip
It is often desirable to call setWebApplicationType(WebApplicationType.NONE) when
using SpringApplication within a JUnit test.

翻译：
一个spring应用程序总代代表你尝试去创建正确的ApplicationContext 上下文类型。决定web应用上下文的算法相当的简单：
* 如果spring mvc存在，使用AnnotationConfigServletWebServerApplicationContext
* 如果spring mvc不存在，spring webflux存在，使用 AnnotationConfigReactiveWebServerApplicationContext
* 其他情况使用 AnnotationConfigApplicationContext
这意味着如果你使用了spring mvc和 spring webflux 在同一个应用里， spring mvc将被默认使用。你可以覆盖上下文类型通过setWebApplicationType()方法。 也可以通过setApplicationContextClass()完全控制上下文类型。

提示：
在JUnittest时 通过使用setWebApplicationType(WebApplicationType.NONE)



23.7 Accessing Application Arguments
If you need to access the application arguments that were passed to SpringApplication.run(…
), you can inject a org.springframework.boot.ApplicationArguments bean. The
ApplicationArguments interface provides access to both the raw String[] arguments as well as
parsed option and non-option arguments, as shown in the following example:
import org.springframework.boot.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.stereotype.*;
@Component
public class MyBean {
@Autowired
public MyBean(ApplicationArguments args) {
boolean debug = args.containsOption("debug");
List<String> files = args.getNonOptionArgs();
// if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
}
}
Tip
Spring Boot also registers a CommandLinePropertySource with the Spring Environment.
This lets you also inject single application arguments by using the @Value annotation.


翻译：
如果你需要访问SpringApplication.run(…) 传递进来的参数，你可以注入org.springframework.boot.ApplicationArguments Bean来获取。ApplicationArguments接口提供了访问未加工的String[]参数，也可以访问解析后的选项和非选项参数



23.8 Using the ApplicationRunner or CommandLineRunner
If you need to run some specific code once the SpringApplication has started, you can implement
the ApplicationRunner or CommandLineRunner interfaces. Both interfaces work in the same way
and offer a single run method, which is called just before SpringApplication.run(…) completes.
The CommandLineRunner interfaces provides access to application arguments as a simple string
array, whereas the ApplicationRunner uses the ApplicationArguments interface discussed
earlier. The following example shows a CommandLineRunner with a run method:
import org.springframework.boot.*;
import org.springframework.stereotype.*;
@Component
public class MyBean implements CommandLineRunner {
public void run(String... args) {
// Do something...
}
}
If several CommandLineRunner or ApplicationRunner beans are defined that must be called in a
specific order, you can additionally implement the org.springframework.core.Ordered interface
or use the org.springframework.core.annotation.Order annotation.


翻译：
23.8 使用ApplicationRunner or CommandLineRunner
如果你想在spring应用程序启动后执行一些代码，你可以实现ApplicationRunner or CommandLineRunner接口。这2个接口有同样的工作方式都提供了一个run方法，当SpringApplication.run(…)方法完成前会被调用。CommandLineRunner接口提供了一个String数组访问应用参数，然后AppliactionRunner使用ApplicationArguments接口提供，如前面介绍过的方式。



23.9 Application Exit
Each SpringApplication registers a shutdown hook with the JVM to ensure that the
ApplicationContext closes gracefully on exit. All the standard Spring lifecycle callbacks (such as
the DisposableBean interface or the @PreDestroy annotation) can be used.
In addition, beans may implement the org.springframework.boot.ExitCodeGenerator
interface if they wish to return a specific exit code when SpringApplication.exit() is called. This
exit code can then be passed to System.exit() to return it as a status code, as shown in the following
example:
@SpringBootApplication
public class ExitCodeApplication {
@Bean
public ExitCodeGenerator exitCodeGenerator() {
return () -> 42;
}
public static void main(String[] args) {
System.exit(SpringApplication
.exit(SpringApplication.run(ExitCodeApplication.class, args)));
}
}
Also, the ExitCodeGenerator interface may be implemented by exceptions. When such an exception
is encountered, Spring Boot returns the exit code provided by the implemented getExitCode()
method.


翻译：
23.9 应用退出
每个spring应用会在jvm注册一个关闭钩子确保在jvm退出是可以优雅的关闭上下文。所有的spring标准声明周期的回调方法都可以使用（例如：DisposableBean接口 或者 @PreDestroy 注解）。另外，可以实现org.springframework.boot.ExitCodeGenerator接口，来实现当SpringApplication.exit() 调用后返回特殊的code



23.10 Admin Features
It is possible to enable admin-related features for the application by
specifying the spring.application.admin.enabled property. This exposes the
SpringApplicationAdminMXBean on the platform MBeanServer. You could use this feature to
administer your Spring Boot application remotely. This feature could also be useful for any service
wrapper implementation.
Tip
If you want to know on which HTTP port the application is running, get the property with a key
of local.server.port.
Caution
Take care when enabling this feature, as the MBean exposes a method to shutdown the
application.


翻译：
23.10 管理员特性
通过特殊的spring.application.admin.enabled 属性可以使用管理员特性。这显示SpringApplicationAdminMXBean在MBeanServer平台上。你可以使用这些特性在远端管理你的spring boot应用。这个特性对任意服务的封装实现也是很有用的。

提示：
如果你想知道那个http端口被应用使用，通过local.server.port属性获得。

小心：
注意启用这个特性，当MBean显示一个关闭应用的方法时


24. Externalized Configuration
Spring Boot lets you externalize your configuration so that you can work with the same application
code in different environments. You can use properties files, YAML files, environment variables, and
command-line arguments to externalize configuration. Property values can be injected directly into your
beans by using the @Value annotation, accessed through Spring’s Environment abstraction, or be
bound to structured objects through @ConfigurationProperties.
Spring Boot uses a very particular PropertySource order that is designed to allow sensible overriding
of values. Properties are considered in the following order:
1. Devtools global settings properties on your home directory (~/.spring-bootdevtools.
properties when devtools is active).
2. @TestPropertySource annotations on your tests.
3. @SpringBootTest#properties annotation attribute on your tests.
4. Command line arguments.
5. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable
or system property).
6. ServletConfig init parameters.
7. ServletContext init parameters.
8. JNDI attributes from java:comp/env.
9. Java System properties (System.getProperties()).
10.OS environment variables.
11.A RandomValuePropertySource that has properties only in random.*.
12.Profile-specific application properties outside of your packaged jar (application-
{profile}.properties and YAML variants).
13.Profile-specific application properties packaged inside your jar (application-
{profile}.properties and YAML variants).
14.Application properties outside of your packaged jar (application.properties and YAML
variants).
15.Application properties packaged inside your jar (application.properties and YAML variants).
16.@PropertySource annotations on your @Configuration classes.
17.Default properties (specified by setting SpringApplication.setDefaultProperties).
To provide a concrete example, suppose you develop a @Component that uses a name property, as
shown in the following example:
import org.springframework.stereotype.*;
import org.springframework.beans.factory.annotation.*;
Spring Boot Reference Guide
2.0.3.RELEASE Spring Boot 60
@Component
public class MyBean {
@Value("${name}")
private String name;
// ...
}
On your application classpath (for example, inside your jar) you can have an
application.properties file that provides a sensible default property value for name. When
running in a new environment, an application.properties file can be provided outside of your jar
that overrides the name. For one-off testing, you can launch with a specific command line switch (for
example, java -jar app.jar --name="Spring").
Tip
The SPRING_APPLICATION_JSON properties can be supplied on the command line with an
environment variable. For example, you could use the following line in a UN*X shell:
$ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar
In the preceding example, you end up with acme.name=test in the Spring Environment. You
can also supply the JSON as spring.application.json in a System property, as shown in
the following example:
$ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar
You can also supply the JSON by using a command line argument, as shown in the following
example:
$ java -jar myapp.jar --spring.application.json='{"name":"test"}'
You can also supply the JSON as a JNDI variable, as follows: java:comp/env/
spring.application.json.


翻译：
24. 具体化配置
spring boot可以让你具体化你的配置，因此你可以在不同的环境中使用一套代码。你可以使用熟悉过文件、YMAML文件、环境变量和命令行参数来具体化配置。属性值可以通过@Value 使用spring抽象黄精来直接注入进bean，或者通过@ConfigurationProperties被绑定到一个object的结构上。

spring boot 使用了一个非常详细的属性资源加载顺序，这样设计目的是允许合理的进行重写属性值。属性值按照如下顺序被使用：
1. devtools 的全局属性设置，在根目录（~/.spring-boot-devtools.properties），当devtools 工具激活时
2. @TestPropertySource ，在测试用例上的 这个注解中
3. 在测试用例的 @SpringBootTest#properties 注解中
4. 命令行参数
5. 在环境变量或者系统属性中的 SPRING_APPLICSTION_JSON 属性中json数据中
6. ServletConfig 初始化参数中
7. ServletContext 初始化参数中
8. java:comp/env 中的JNDI属性
9. java系统属性 System.getProperties()
10. 操作系统环境变量
11. RandomValuePropertySource 属性 random.*
12. 其他包中的个人应用配置 application- {profile}.properties and YAML
13. 本jar包中的个人应用配置 application- {profile}.properties and YAML
14. 其他包中的 application.properties and YAML
15. 本jar包中的 application.properties and YAML
16. 通过 @PropertySource 注解在@Configuration注解的类中
17. 通过SpringApplication.setDefaultProperties 设置的默认属性

在你的应用程序classpath中（例如，在你的jar包中）你可以用application.properties提供一个明智的默认属性。当运行在一个新环境中，application.properties文件可以被jar包外部的参数覆盖。 在一个测试中，你可以通过命令行启动来测试，例如：java -jar app.jar --name="Spring"

提示：
SPRING_APPLICATION_JSON属性可以在命令行中作为环境变量提供，例如： 在Unix shell :
$ SPRING_APPLICATION_JSON='{name":"test"}' java -jar myapp.

在前面的例子中，你可以以acme.name=test作为结束在一个spring环境中。你也可以在jvm系统属性中增加 spring.application.json属性，例如：
$ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar

你也可以在命令行使用参数：
$ java -jar myapp.jar --spring.application.json='{"name":"test"}'

你也可以在JNDI中使用
java:comp/env/spring.application.json




24.1 Configuring Random Values
The RandomValuePropertySource is useful for injecting random values (for example, into secrets or test cases). It can produce integers, longs, uuids, or strings, as shown in the following example:

my.secret=${random.value}
my.number=${random.int}
my.bignumber=${random.long}
my.uuid=${random.uuid}
my.number.less.than.ten=${random.int(10)}
my.number.in.range=${random.int[1024,65536]}

The random.int* syntax is OPEN value (,max) CLOSE where the OPEN,CLOSE are any character and value,max are integers. If max is provided, then value is the minimum value and max is the maximum value (exclusive).


翻译：
24.1配置随机值
RandomValuePropertySource 用来诸如随机值，它提供integers, longs, uuids, or strings
random.int.* 语法以value起始 ,max结束， 开始结束符可以是任意字符， 起始和最大值必须是整数




24.2 Accessing Command Line Properties
By default, SpringApplication converts any command line option arguments (that is, arguments starting with --, such as --server.port=9000) to a property and adds them to the Spring Environment. As mentioned previously, command line properties always take precedence over other property sources.
If you do not want command line properties to be added to the Environment, you can disable them by using SpringApplication.setAddCommandLineProperties(false).

翻译：
24.2 访问命令行属性
默认下，spring应用使用命令行参数覆盖到spirng环境中，（通过 --参数名 --server.port=9000 增加命令行参数）,命令行提供的属性总是有限级高于其他属性来源。如果你不想使用命令行属性加入到环境，可以设置SpringApplication.setAddCommandLineProperties(false)



24.3 Application Property Files
SpringApplication loads properties from application.properties files in the following locations and adds them to the Spring Environment:
1. A /config subdirectory of the current directory 2. The current directory
3. A classpath /config package
4. The classpath root
The list is ordered by precedence (properties defined in locations higher in the list override those defined in lower locations).

Note
You can also use YAML ('.yml') files as an alternative to '.properties'.
If you do not like application.properties as the configuration file name, you can switch to another file name by specifying a spring.config.name environment property. You can also refer to an explicit location by using the spring.config.location environment property (which is a comma-separated list of directory locations or file paths). The following example shows how to specify a different file name:

$ java -jar myproject.jar --spring.config.name=myproject


The following example shows how to specify two locations:
$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/
override.properties


Warning
spring.config.name and spring.config.location are used very early to determine which files have to be loaded, so they must be defined as an environment property (typically an OS environment variable, a system property, or a command-line argument).

If spring.config.location contains directories (as opposed to files), they should end in / (and, at runtime, be appended with the names generated from spring.config.name before being loaded, including profile-specific file names). Files specified in spring.config.location are used as-is, with no support for profile-specific variants, and are overridden by any profile-specific properties.

Config locations are searched in reverse order. By default, the configured locations are classpath:/,classpath:/config/,file:./,file:./config/. The resulting search order is the following:
1. file:./config/
2. file:./
3. classpath:/config/ 4. classpath:/

When custom config locations are configured by using spring.config.location, they replace the default locations. For example, if spring.config.location is configured with the value classpath:/custom-config/,file:./custom-config/, the search order becomes the following:
1. file:./custom-config/
2. classpath:custom-config/

Alternatively, when custom config locations are configured by using spring.config.additional- location, they are used in addition to the default locations. Additional locations are searched before the default locations. For example, if additional locations of classpath:/custom- config/,file:./custom-config/ are configured, the search order becomes the following:
1. file:./custom-config/
2. classpath:custom-config/
3. file:./config/
4. file:./
5. classpath:/config/
6. classpath:/

This search ordering lets you specify default values in one configuration file and then selectively override those values in another. You can provide default values for your application in application.properties (or whatever other basename you choose with spring.config.name) in one of the default locations. These default values can then be overridden at runtime with a different file located in one of the custom locations.

Note
If you use environment variables rather than system properties, most operating systems disallow period-separated key names, but you can use underscores instead (for example, SPRING_CONFIG_NAME instead of spring.config.name).

Note
If your application runs in a container, then JNDI properties (in java:comp/env) or servlet context initialization parameters can be used instead of, or as well as, environment variables or system properties.


翻译：
24.3 应用属性文件
spring应用从以下位置加载application.properties属性文件：
1. 当前目录下的 /config子目录
2. 当前目录
3. classpath 下的/config目录
4. classpath 下

注意：
你可以从 yml 和properties 二选一使用

如果你不喜欢用appliation.properties 当作配置文件名称，你可以用spring.config.name指定其他名字。你也可以通过spring.config.location 明确配置文件路径（通过逗号分隔多个文件）

警告：
spring.config.name和spring.config.location 是非常早被使用到的，因此必须定义在环境变量中，例如（操作系统环境变量、jvm系统属性、命令行参数）

如果spring.config.location 指定到了目录而不是文件，则必须以/结尾。在运行时 spring.config.name 参数会先使用指定文件名字后再加载文件，包括个人配置名字。spring.config.location指定的文件在没有个人配置的情况下按照原本内容使用，如果有任何的个人配置属性，则将会覆盖它
,  ,  ,
1. file:./config/
2. file:./
3. classpath:/config/
4. classpath:/

当通过spring.config.location 指定了文件位置时， 例如spring.config.location = classpath:/custom-config/,file:./custom-config/ ，那么搜索配置文件的顺序是：
1. file:./custom-config/
2. classpath:/custom-config/az

二选一的，当通过spring.config.additional-location设置配置文件路径时，路径被当作默认路径一起使用，添加的路径优先于默认路径被查找。例如：spring.config.additional-location=classpath:/custom- config/,file:./custom-config/，那么搜索配追文件顺序是：
1. file:./custom-config/
2. classpath:/custom- config/
3. file:./config/
4. file:./
5. classpath:/config/
6. classpath:/

这种查找顺序可以让你在一个配置文件中定义默认值，然后有选择的在其他文件中覆盖它们。你可以在application.properties中设置默认值，默认值会被定制位置的文件中的值覆盖。

注意：
如果你使用环境变量而不用jvm系统属性，大多数操作系统属性名不允许使用. ，你可以使用下划线替代。例如SPRING_APPLICATION_NAME

注意：
如果你的应用跑在容器中，那么JNDI属性和servlet 容器初始化参数的值将被使用，替代环境变量和jvm系统属性。


24.4 Profile-specific Properties
In addition to application.properties files, profile-specific properties can also be defined by using the following naming convention: application-{profile}.properties. The Environment has a set of default profiles (by default, [default]) that are used if no active profiles are set. In other words, if no profiles are explicitly activated, then properties from application-default.properties are loaded.

Profile-specific properties are loaded from the same locations as standard application.properties, with profile-specific files always overriding the non-specific ones, whether or not the profile-specific files are inside or outside your packaged jar.

If several profiles are specified, a last-wins strategy applies. For example, profiles specified by the spring.profiles.active property are added after those configured through the SpringApplication API and therefore take precedence.

Note
If you have specified any files in spring.config.location, profile-specific variants of those files are not considered. Use directories in spring.config.location if you want to also use profile-specific properties.

翻译：
24.4 个人配置属性
除了application.properties文件外，个人配置属性也可以通过如下约定定义：application-{profile}.properties。当没有个人配置文件被激活时环境中书用默认的个人配置，换句话说如果没有个人配置被激活application-default.properties会被加载。

在同样的位置个人配置属性将被加载，并作为标准的应用属性，个人配置属性总是覆盖非给人配置的属性，无论个人配置属性是否在jar包内。

如果有许多个人配置属性文件，最终只有一个会被使用。 通过 spring.profiles.active 定义的配置文件将被加载

注意：
如果你在spring.config.location 中定义了任何文件， 个人属性配置将不会生效，如果你想让它生效 spring.config.location 中使用目录而非具体文件


24.5 Placeholders in Properties
The values in application.properties are filtered through the existing Environment when they are used, so you can refer back to previously defined values (for example, from System properties).

app.name=MyApp
app.description=${app.name} is a Spring Boot application

Tip
You can also use this technique to create “short” variants of existing Spring Boot properties. See the Section 74.4, “Use ‘Short’ Command Line Arguments” how-to for details.

翻译：
24.5 属性文件占位符
application.properties中的值在使用的时候会被环境过滤，所以可以使用前面定义的变量值給后面的使用

你可以使用这个技巧在spring boot 属性中定义一下短的变量来使用。




24.6 Using YAML Instead of Properties
YAML is a superset of JSON and, as such, is a convenient format for specifying hierarchical configuration data. The SpringApplication class automatically supports YAML as an alternative to properties whenever you have the SnakeYAML library on your classpath.

[Note]
If you use “Starters”, SnakeYAML is automatically provided by spring-boot-starter.

24.6.1 Loading YAML
Spring Framework provides two convenient classes that can be used to load YAML documents. The YamlPropertiesFactoryBean loads YAML as Properties and the YamlMapFactoryBean loads YAML as a Map.

For example, consider the following YAML document:

environments:
    dev:
        url: http://dev.example.com
        name: Developer Setup
    prod:
        url: http://another.example.com
        name: My Cool App
The preceding example would be transformed into the following properties:

environments.dev.url=http://dev.example.com
environments.dev.name=Developer Setup
environments.prod.url=http://another.example.com
environments.prod.name=My Cool App
YAML lists are represented as property keys with [index] dereferencers. For example, consider the following YAML:

my:
servers:
    - dev.example.com
    - another.example.com
The preceding example would be transformed into these properties:

my.servers[0]=dev.example.com
my.servers[1]=another.example.com
To bind to properties like that by using Spring Boot’s Binder utilities (which is what @ConfigurationProperties does), you need to have a property in the target bean of type java.util.List (or Set) and you either need to provide a setter or initialize it with a mutable value. For example, the following example binds to the properties shown previously:

@ConfigurationProperties(prefix="my")
public class Config {

    private List<String> servers = new ArrayList<String>();

    public List<String> getServers() {
        return this.servers;
    }
}
24.6.2 Exposing YAML as Properties in the Spring Environment
The YamlPropertySourceLoader class can be used to expose YAML as a PropertySource in the Spring Environment. Doing so lets you use the @Value annotation with placeholders syntax to access YAML properties.

24.6.3 Multi-profile YAML Documents
You can specify multiple profile-specific YAML documents in a single file by using a spring.profiles key to indicate when the document applies, as shown in the following example:

server:
    address: 192.168.1.100
---
spring:
    profiles: development
server:
    address: 127.0.0.1
---
spring:
    profiles: production & eu-central
server:
    address: 192.168.1.120
In the preceding example, if the development profile is active, the server.address property is 127.0.0.1. Similarly, if the production and eu-central profiles are active, the server.address property is 192.168.1.120. If the development, production and eu-central profiles are not enabled, then the value for the property is 192.168.1.100.

[Note]
spring.profiles can therefore contain a simple profile name (for example production) or a profile expression. A profile expression allows for more complicated profile logic to be expressed, for example production & (eu-central | eu-west). Check the reference guide for more details.

If none are explicitly active when the application context starts, the default profiles are activated. So, in the following YAML, we set a value for spring.security.user.password that is available only in the "default" profile:

server:
  port: 8000
---
spring:
  profiles: default
  security:
    user:
      password: weak
Whereas, in the following example, the password is always set because it is not attached to any profile, and it would have to be explicitly reset in all other profiles as necessary:

server:
  port: 8000
spring:
  security:
    user:
      password: weak
Spring profiles designated by using the spring.profiles element may optionally be negated by using the ! character. If both negated and non-negated profiles are specified for a single document, at least one non-negated profile must match, and no negated profiles may match.

24.6.4 YAML Shortcomings
YAML files cannot be loaded by using the @PropertySource annotation. So, in the case that you need to load values that way, you need to use a properties file.


翻译：
24.6 使用YAML 替代 属性文件
YAML时一个JSON的超集，它本身是一个定义层级关系数据的很方便的格式。spring应用自动支持YAML，当Snake YAML库在你的classpath上时。

注意：
spring-boot-starter 自动提供Snake YAML支持


24.6.1 加载YAML
spring 框架提供了2个便利的类加载YAML文档。 YamlPropertiesFactoryBean 加载YAML为属性，YamlMapFactoryBean加载YAML为Map

例：
集合定义
my:
    servers:
        - dev.example.com
        - another.example.com
相当于
my.servers[0]=deve.example.com
my.servers[1]=another.example.com

绑定这样的集合值可以通过spring的Binder工具，例如@ConfigurationProperties，你需要先在bean中定义List或Set属性，然后设置set方法或者初始化它们，例如：

@ConfigurationProperties(prefix="my")
public class Config {

    private List<String> servers = new ArrayList<String>();

    public List<String> getServers() {
        return this.servers;
    }
}


24.6.2 作为属性在spring环境中显示YAML
在spring的环境中 YamlPropertySourceLoader 类使用YAML作为PropertySource。使用@Value注解和占位符语法来访问YAML属性


24.6.3 多个个人YAML文档
在一个YAML文件中可以定义多个个人配置， 使用spring.profiles 属性来明确使用那个

server:
    address: 192.168.1.100
---
spring:
    profiles: development
server:
    address: 127.0.0.1
---
spring:
    profiles: production & eu-central
server:
    address: 192.168.1.120

根据上面的例子，如果development配置被激活，server.address 将是127.0.0.1，如果production 和 eu-central配置被激活则server.address 使用 192.168.1.120，如果这3个都没有被激活，则使用192.168.1.100

注意：
spring.profiles 因此可以有一个简单的名字（例如：production）或者一个表达式。表达式可以使用复杂逻辑，例如（production & (eu-central | eu-west))

如果在上下文一开始没有明确激活个人配置，默认的会被使用。所以下面定义的spring.security.user.password 属性只在 default配置中生效。
server:
  port: 8000
---
spring:
  profiles: default
  security:
    user:
      password: weak

反之，下面的例子password将总是生效，因为它没有附加在任何个人配置中，
server:
  port: 8000
spring:
  security:
    user:
      password: weak

spring 的个人配置 通过spring.profile-specific指定，并且可以使用!字符来否定。如果否定的河非否定的个人配置在一个配置文件中，那么至少一个非否定个人配置将会匹配，否定的将不会被匹配

YAML的不足：
YAML文件不能使用@PropertySource注解来加载，所以这种情况下只能使用属性文件。



24.7 类型安全的配置属性

使用@Value("${property}")注解来注入配置文件属性有时是很笨重的，尤其是当你的有多个属性或者属性是分层嵌套的。
Spring Boot提供了一个可选的处理方法，这种方法可以让你的应用管理和验证bean的属性类型。

使用@ConfigurationProperties 注解注入属性文件
使用@EnableConfigurationProperties({x1.class, x2.class}) 可以将多个@ConfigurationProperties配置的bean引入并自动注册

例如：
@ConfigurationProperties(prefix="acme")
public class AcmeProperties {
    private String name;
    ......
}

@Configuration
@EnableConfigurationProperties({AcmeProperties.class})
public class MyConfiguration{

    @Bean
    public OtherBean(AcmeProperties acmeProperties){
        return new OtherBean(acmeProperties);
    }

    @Bean
    public AcmeProperties getAcmeProperties(){
        return new AcmeProperties();
    }
}


@Component
@ConfigurationProperties(prefix="mybean")
public class MyBean {
    private String name;
    ......
}

@Service
public class MyService{

    @AutoWired
    private MyBean myBean;

}



24.7.3 合并复合类型

当list属性配置了多个，覆盖时会覆盖整个list。优先级最高的会被使用。
例如：
@ConfigurationProperties("acme")
public class AcmeProperties {

    private final List<MyPojo> list = new ArrayList<>();

    public List<MyPojo> getList() {
        return this.list;
    }

}

public class MuyPojo{
    private String name;
    private String description;
}

yaml文件：
acme:
  list:
    - name: my name
      description: my description
    - name: another name
      description: another description
---
spring:
  profiles: dev
acme:
  list:
    - name: my another name

如果dev没有被激活，list 包含两个对象， my name/my description 和 another name/another description
如果dev被激活，list包含1个对象，my another name/null



Map属性的值怎可以从多个配置中获取，同样的属性名使用优先级最高的配置。
例如：
acme:
  map:
    key1:
      name: my name 1
      description: my description 1
---
spring:
  profiles: dev
acme:
  map:
    key1:
      name: dev name 1
    key2:
      name: dev name 2
      description: dev description 2

dev被激活，则map 有2个对象，key1 : dev name 1/my description 1 和 key2 : dev name 2／dev description 2



















































